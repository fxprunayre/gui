// This file is auto-generated by @hey-api/openapi-ts

import {estypes} from "@elastic/elasticsearch";

export type Address = {
    address?: string;
    city?: string;
    country?: string;
    id?: number;
    state?: string;
    zip?: string;
};

export type AnonymousMapserver = {
    configurl?: string;
    description?: string;
    id?: number;
    name?: string;
    namespace?: string;
    namespacePrefix?: string;
    password?: string;
    pushStyleInWorkspace?: MapServer;
    pushStyleInWorkspace_JpaWorkaround?: string;
    stylerurl?: string;
    username?: string;
    wcsurl?: string;
    wfsurl?: string;
    wmsurl?: string;
};

export type Associated = {
    item?: Array<AssociatedSiblingMetadataItem>;
};

export type AssociatedRecord = {
    _id?: string;
    _source?: JsonNode;
    origin?: string;
    properties?: {
        [key: string]: (string);
    };
};

export type AssociatedSiblingMetadataItem = {
    agg_isDescriptionOf?: Array<(string)>;
    agg_isTemporalStatOf?: Array<(string)>;
    agg_largerWorkCitation?: Array<(string)>;
    description: Description;
    hash?: string;
    id?: string;
    idx?: string;
    mdType: Array<(string)>;
    origin?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type AttributeTable = {
    element?: Array<FCRelatedElement>;
};

export type BatchEditParameter = {
    condition?: string;
    value: string;
    xpath: string;
};

export type BatchEditing = {
    section: Array<Section>;
};

export type Category = {
    id?: string;
    label?: string;
};

export type CategoryResponse = {
    label?: {
        [key: string]: (string);
    };
};

export type Children = {
    item?: Array<RelatedMetadataItem>;
};

export type Codelist = {
    alias?: string;
    entry?: Array<Entry>;
    name?: string;
};

export type Crs = {
    authority?: string;
    code?: string;
    codeSpace?: string;
    description?: string;
    version?: string;
};

export type Dataset = {
    item?: Array<RelatedMetadataItem>;
};

export type Description = {
    value?: Array<LocalizedString>;
};

export type Direction = 'up' | 'down';

export type Element = {
    condition?: string;
    context?: string;
    description?: string;
    example?: string;
    help?: string;
    helper?: Helper;
    id?: number;
    label: string;
    name?: string;
};

export type Entry = {
    code: string;
    description: string;
    hideInEditMode?: string;
    label: string;
};

export type ExtentDto = {
    description?: string;
    href?: string;
    type?: string;
    xpath?: string;
};

export type FCRelatedElement = {
    code?: string;
    definition?: string;
    link?: string;
    name?: string;
    type?: string;
    values?: Array<Values>;
};

export type FCRelatedMetadataItem = {
    description: Description;
    featureType: FeatureType;
    hash?: string;
    id?: string;
    idx?: string;
    mdType: Array<(string)>;
    origin?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type Fcat = {
    item?: Array<FCRelatedMetadataItem>;
};

export type FeatureResponse = {
    decodeMap?: {
        [key: string]: Array<(string)>;
    };
};

export type FeatureType = {
    attributeTable?: AttributeTable;
};

export type Field = {
    codelist?: string;
    indexField?: string;
    insertMode?: string;
    name?: string;
    removable?: boolean;
    template?: string;
    use?: string;
    xpath?: string;
};

export type FormatterData = {
    id?: string;
    schema?: string;
};

export type FormatterDataResponse = {
    formatters?: Array<FormatterData>;
};

export type GrantedAuthority = {
    authority?: string;
};

/**
 * Group details
 */
export type Group = {
    allowedCategories?: Array<MetadataCategory>;
    defaultCategory?: MetadataCategory;
    description?: string;
    email?: string;
    enableAllowedCategories?: boolean;
    id?: number;
    label?: {
        [key: string]: (string);
    };
    logo?: string;
    name?: string;
    referrer?: number;
    reserved?: boolean;
    website?: string;
};

export type GroupOperations = {
    group?: number;
    operations?: {
        [key: string]: (boolean);
    };
};

export type GroupPrivilege = {
    group?: number;
    operations?: {
        [key: string]: (boolean);
    };
    reserved?: boolean;
    userGroup?: boolean;
    userProfile?: Array<('Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor')>;
    userProfiles?: Array<('Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor')>;
};

export type Hasfeaturecats = {
    item?: Array<RelatedMetadataItem>;
};

export type Hassource = {
    item?: Array<RelatedMetadataItem>;
};

export type Helper = {
    displayIf?: string;
    editorMode?: string;
    option: Array<Option>;
    rel?: string;
    relAtt?: string;
    sort?: boolean;
};

export type IProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    running?: boolean;
    startIsoDateTime?: string;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type ISODate = {
    dateAndTime?: string;
    dateAndTimeUtc?: string;
    dateAsString?: string;
    dateOnly?: boolean;
    dateYearMonthOnly?: boolean;
    dateYearOnly?: boolean;
    days?: number;
    hours?: number;
    internalDateTime?: string;
    minutes?: number;
    months?: number;
    seconds?: number;
    timeAsString?: string;
    timeInSeconds?: number;
    years?: number;
};

export type IndexResponse = {
    count?: number;
    success?: boolean;
};

export type InfoReport = {
    approved?: boolean;
    date?: string;
    draft?: boolean;
    message?: string;
    uuid?: string;
};

export type IsoLanguage = {
    code?: string;
    id?: number;
    label?: {
        [key: string]: (string);
    };
    shortCode?: string;
};

export type JsonNode = {
    [key: string]: unknown;
};

export type Language = {
    id?: string;
    inspire?: boolean;
    inspire_JPAWorkaround?: string;
    name?: string;
};

export type Link = {
    id?: number;
    lastCheck?: ISODate;
    lastState?: number;
    linkStatus?: Array<LinkStatus>;
    linkType?: 'HTTP' | 'METADATA';
    protocol?: string;
    records?: Array<MetadataLink>;
    url?: string;
};

export type linkType = 'HTTP' | 'METADATA';

export type LinkFilter = {
    lastState?: string;
    records?: string;
    url?: string;
};

export type LinkStatus = {
    batchKey?: string;
    checkDate?: ISODate;
    failing?: boolean;
    id?: number;
    statusInfo?: string;
    statusValue?: string;
};

export type ListRegionsResponse = {
    categories?: {
        [key: string]: CategoryResponse;
    };
    count?: number;
    region?: Array<RegionResponse>;
    regions?: Array<RegionResponse>;
};

export type LocalizedString = {
    href?: string;
    lang?: string;
    value?: string;
};

export type LogFileResponse = {
    file?: string;
    name?: string;
};

/**
 * Mapserver details
 */
export type MapServer = {
    configurl?: string;
    description?: string;
    id?: number;
    name?: string;
    namespace?: string;
    namespacePrefix?: string;
    password?: string;
    pushStyleInWorkspace?: MapServer;
    pushStyleInWorkspace_JpaWorkaround?: string;
    stylerurl?: string;
    username?: string;
    wcsurl?: string;
    wfsurl?: string;
    wmsurl?: string;
};

export type MapService = {
    authType?: string;
    url?: string;
    urlType?: string;
    useProxy?: boolean;
};

export type MeResponse = {
    admin?: boolean;
    email?: string;
    groupsWithEditor?: Array<(number)>;
    groupsWithRegisteredUser?: Array<(number)>;
    groupsWithReviewer?: Array<(number)>;
    groupsWithUserAdmin?: Array<(number)>;
    hash?: string;
    id?: string;
    name?: string;
    organisation?: string;
    profile?: string;
    surname?: string;
    username?: string;
};

export type MetadataBatchApproveParameter = {
    bucket?: string;
    directApproval?: boolean;
    message?: string;
    uuids?: Array<(string)>;
};

export type MetadataBatchSubmitParameter = {
    bucket?: string;
    message?: string;
    uuids?: Array<(string)>;
};

export type MetadataCategory = {
    id?: number;
    label?: {
        [key: string]: (string);
    };
    name?: string;
};

/**
 * Identifier template details
 */
export type MetadataIdentifierTemplate = {
    id?: number;
    name?: string;
    systemDefault?: boolean;
    systemProvided?: boolean;
    systemProvided_JPAWorkaround?: string;
    template?: string;
};

export type MetadataLink = {
    metadataId?: number;
    metadataUuid?: string;
};

export type MetadataProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    errors?: Array<Report>;
    infos?: Array<InfoReport>;
    metadata?: Array<(number)>;
    metadataErrors?: {
        [key: string]: Array<Report>;
    };
    metadataInfos?: {
        [key: string]: Array<InfoReport>;
    };
    numberOfNullRecords?: number;
    numberOfRecordNotFound?: number;
    numberOfRecords?: number;
    numberOfRecordsNotEditable?: number;
    numberOfRecordsProcessed?: number;
    numberOfRecordsUnchanged?: number;
    numberOfRecordsWithErrors?: number;
    running?: boolean;
    startIsoDateTime?: string;
    totalRecords?: number;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type MetadataReplacementProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    errors?: Array<Report>;
    infos?: Array<InfoReport>;
    metadata?: Array<(number)>;
    metadataChanges?: {
        [key: string]: ReplaceReport;
    };
    metadataErrors?: {
        [key: string]: Array<Report>;
    };
    metadataInfos?: {
        [key: string]: Array<InfoReport>;
    };
    noProcessFoundCount?: number;
    numberOfNullRecords?: number;
    numberOfRecordNotFound?: number;
    numberOfRecords?: number;
    numberOfRecordsChanged?: number;
    numberOfRecordsNotChanged?: number;
    numberOfRecordsNotEditable?: number;
    numberOfRecordsProcessed?: number;
    numberOfRecordsUnchanged?: number;
    numberOfRecordsWithErrors?: number;
    processId?: string;
    running?: boolean;
    startIsoDateTime?: string;
    totalRecords?: number;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type MetadataResource = {
    approved?: boolean;
    filename?: string;
    id?: string;
    lastModification?: string;
    metadataId?: number;
    metadataResourceExternalManagementProperties?: MetadataResourceExternalManagementProperties;
    metadataUuid?: string;
    size?: number;
    url?: string;
    version?: string;
    visibility?: 'PUBLIC' | 'PRIVATE';
};

export type visibility = 'PUBLIC' | 'PRIVATE';

export type MetadataResourceExternalManagementProperties = {
    id?: string;
    url?: string;
    validationStatus?: 'UNKNOWN' | 'VALID' | 'INCOMPLETE';
};

export type validationStatus = 'UNKNOWN' | 'VALID' | 'INCOMPLETE';

export type MetadataStatusDto = {
    changeDate?: ISODate;
    changeMessage?: string;
    closeDate?: ISODate;
    currentState?: string;
    dueDate?: ISODate;
    id?: number;
    metadataId?: number;
    owner?: number;
    previousState?: string;
    relatedMetadataStatusId?: number;
    statusValue?: StatusValue;
    titles?: {
        [key: string]: (string);
    };
    userId?: number;
    uuid?: string;
};

/**
 * Metadata status
 */
export type MetadataStatusParameter = {
    changeMessage?: string;
    closeDate?: string;
    dueDate?: string;
    owner?: number;
    status?: number;
    type?: 'workflow' | 'task' | 'event';
};

export type type = 'workflow' | 'task' | 'event';

export type MetadataStatusResponse = {
    authorEmail?: string;
    authorName?: string;
    authorProfile?: string;
    changeDate?: ISODate;
    changeMessage?: string;
    closeDate?: ISODate;
    currentState?: string;
    currentStateEmpty?: boolean;
    currentStatus?: string;
    dateChange?: string;
    dateClose?: string;
    dateDue?: string;
    dueDate?: ISODate;
    id?: number;
    metadataId?: number;
    owner?: number;
    ownerEmail?: string;
    ownerName?: string;
    ownerProfile?: string;
    previousState?: string;
    previousStateEmpty?: boolean;
    previousStatus?: string;
    relatedMetadataStatusId?: number;
    statusId?: number;
    statusValue?: StatusValue;
    title?: string;
    titles?: {
        [key: string]: (string);
    };
    userId?: number;
    uuid?: string;
};

export type MetadataWorkflowStatusResponse = {
    currentStatus?: MetadataStatusDto;
    hasEditPermission?: boolean;
    reviewers?: Array<User>;
    status?: Array<StatusValue>;
};

export type MultilingualValue = {
    value?: Array<LocalizedString>;
};

export type Online = {
    item?: Array<RelatedLinkItem>;
};

export type Operation = {
    id?: number;
    label?: {
        [key: string]: (string);
    };
    name?: string;
    reserved?: boolean;
    reservedOperation?: 'view' | 'download' | 'editing' | 'notify' | 'dynamic' | 'featured';
};

export type reservedOperation = 'view' | 'download' | 'editing' | 'notify' | 'dynamic' | 'featured';

export type Option = {
    description?: string;
    isDefault?: boolean;
    label?: string;
    value?: string;
};

export type OwnerResponse = {
    id?: number;
    name?: string;
    records?: number;
};

export type PageLink = {
    content?: Array<Link>;
    empty?: boolean;
    first?: boolean;
    last?: boolean;
    number?: number;
    numberOfElements?: number;
    pageable?: PageableObject;
    size?: number;
    sort?: Array<SortObject>;
    totalElements?: number;
    totalPages?: number;
};

export type PageProperties = {
    content?: string;
    format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
    icon?: string;
    label?: string;
    language?: string;
    link?: string;
    pageId?: string;
    sections?: Array<('TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3')>;
    status?: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';
};

export type format = 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';

export type status = 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';

export type PageableObject = {
    offset?: number;
    pageNumber?: number;
    pageSize?: number;
    paged?: boolean;
    sort?: Array<SortObject>;
    unpaged?: boolean;
};

export type PaginatedUserSearchResponse = {
    rows?: Array<UserSearchDto>;
    total?: number;
};

export type Parent = {
    item?: Array<RelatedMetadataItem>;
};

export type PasswordResetDto = {
    password?: string;
    password2?: string;
    passwordOld?: string;
};

/**
 * The new password and a valid change key
 */
export type PasswordUpdateParameter = {
    changeKey?: string;
    password?: string;
};

export type Pattern = {
    rules: Rules;
    title: string;
};

export type Patterns = {
    pattern: Array<Pattern>;
};

export type ProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    errors?: Array<Report>;
    infos?: Array<InfoReport>;
    running?: boolean;
    startIsoDateTime?: string;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type ProxyConfiguration = {
    enabled?: boolean;
    host?: string;
    ignoreHostList?: string;
    password?: string;
    port?: string;
    proxyConfiguredInSystemProperties?: boolean;
    username?: string;
};

export type PublicationOption = {
    additionalPublications?: {
        [key: string]: Array<ReservedOperation>;
    };
    name?: string;
    publicationGroup?: ReservedGroup;
    publicationOperations?: Array<ReservedOperation>;
};

export type RatingAverage = {
    lastComment?: string;
    ratingAverages?: {
        [key: string]: (number);
    };
    ratingCount?: number;
    userfeedbackCount?: number;
};

export type RatingCriteria = {
    id?: number;
    internal?: boolean;
    label?: {
        [key: string]: (string);
    };
    name?: string;
};

export type RegionResponse = {
    categoryId?: string;
    east?: number;
    hasGeom?: boolean;
    id?: string;
    label?: {
        [key: string]: (string);
    };
    north?: number;
    south?: number;
    west?: number;
};

export type Related = {
    item?: Array<RelatedMetadataItem>;
};

export type RelatedItemType = 'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails';

export type RelatedLinkItem = {
    applicationProfile?: string;
    description: Description;
    function?: string;
    hash?: string;
    id?: string;
    idx?: string;
    mimeType?: string;
    protocol?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type RelatedMetadataItem = {
    description: Description;
    hash?: string;
    id?: string;
    idx?: string;
    mdType: Array<(string)>;
    origin?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type RelatedResponse = {
    associated?: Associated;
    children?: Children;
    datasets?: Dataset;
    fcats?: Fcat;
    hasfeaturecats?: Hasfeaturecats;
    hassources?: Hassource;
    onlines?: Online;
    parent?: Parent;
    related?: Related;
    services?: Service;
    siblings?: Siblings;
    sources?: RelatedSource;
    thumbnails?: Thumbnail;
};

export type RelatedSiblingMetadataItem = {
    associationType: string;
    description: Description;
    hash?: string;
    id?: string;
    idx?: string;
    initiativeType: string;
    mdType: Array<(string)>;
    origin?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type RelatedSource = {
    item?: Array<RelatedMetadataItem>;
};

export type RelatedThumbnailItem = {
    hash?: string;
    id?: string;
    idx?: string;
    title: MultilingualValue;
    type?: string;
    url?: MultilingualValue;
};

export type ReplaceEntryChange = {
    changedVal?: string;
    fieldId?: string;
    originalVal?: string;
};

export type ReplaceReport = {
    approved?: boolean;
    date?: string;
    draft?: boolean;
    elementChanges?: Array<ReplaceEntryChange>;
    message?: string;
    uuid?: string;
};

export type Report = {
    approved?: boolean;
    date?: string;
    draft?: boolean;
    message?: string;
    uuid?: string;
};

export type Reports = {
    report?: Array<ValidationReport>;
};

export type ReservedGroup = 'all' | 'intranet' | 'guest';

export type ReservedOperation = 'view' | 'download' | 'editing' | 'notify' | 'dynamic' | 'featured';

export type Rule = {
    details: string;
    group?: string;
    id?: string;
    msg?: string;
    ref?: string;
    test?: string;
    type?: string;
};

export type Rules = {
    rule?: Array<Rule>;
};

export type SavedQuery = {
    cleanValues?: string;
    id?: string;
    label?: string;
    parameters?: Array<(string)>;
    xpath?: string;
};

export type Section = {
    field: Array<Field>;
    name?: string;
};

export type Selection = {
    id?: number;
    label?: {
        [key: string]: (string);
    };
    name?: string;
    watchable?: boolean;
};

export type Service = {
    item?: Array<RelatedMetadataItem>;
};

export type Setting = {
    dataType?: 'STRING' | 'INT' | 'BOOLEAN' | 'JSON';
    editable?: boolean;
    editable_JpaWorkaround?: string;
    encrypted?: boolean;
    encrypted_JpaWorkaround?: string;
    internal?: boolean;
    internal_JpaWorkaround?: string;
    name?: string;
    position?: number;
    storedValue?: string;
    value?: string;
};

export type dataType = 'STRING' | 'INT' | 'BOOLEAN' | 'JSON';

export type SettingsListResponse = {
    settings?: Array<Setting>;
};

/**
 * Privileges
 */
export type SharingParameter = {
    clear?: boolean;
    privileges?: Array<GroupOperations>;
};

export type SharingResponse = {
    groupOwner?: string;
    owner?: string;
    privileges?: Array<GroupPrivilege>;
};

export type Siblings = {
    item?: Array<RelatedSiblingMetadataItem>;
};

export type SimpleMetadataProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    errors?: Array<Report>;
    infos?: Array<InfoReport>;
    metadata?: Array<(number)>;
    metadataErrors?: {
        [key: string]: Array<Report>;
    };
    metadataInfos?: {
        [key: string]: Array<InfoReport>;
    };
    numberOfNullRecords?: number;
    numberOfRecordNotFound?: number;
    numberOfRecords?: number;
    numberOfRecordsNotEditable?: number;
    numberOfRecordsProcessed?: number;
    numberOfRecordsUnchanged?: number;
    numberOfRecordsWithErrors?: number;
    running?: boolean;
    startIsoDateTime?: string;
    totalRecords?: number;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type SiteInformation = {
    catalogue?: {
        [key: string]: (string);
    };
    database?: {
        [key: string]: (string);
    };
    env?: {
        [key: string]: (string);
    };
    index?: {
        [key: string]: (string);
    };
    main?: {
        [key: string]: (string);
    };
    version?: {
        [key: string]: (string);
    };
};

export type SortObject = {
    ascending?: boolean;
    direction?: string;
    ignoreCase?: boolean;
    nullHandling?: string;
    property?: string;
};

export type Source = {
    creationDate?: ISODate;
    filter?: string;
    groupOwner?: number;
    label?: {
        [key: string]: (string);
    };
    listableInHeaderSelector?: boolean;
    logo?: string;
    name?: string;
    serviceRecord?: string;
    type?: 'portal' | 'subportal' | 'externalportal' | 'harvester';
    uiConfig?: string;
    uuid?: string;
};

export type type2 = 'portal' | 'subportal' | 'externalportal' | 'harvester';

export type Status = {
    date?: string;
    id?: string;
    message?: string;
    state?: 'RED' | 'UNINITIALIZED' | 'YELLOW' | 'GREEN' | 'DISABLED';
};

export type state = 'RED' | 'UNINITIALIZED' | 'YELLOW' | 'GREEN' | 'DISABLED';

export type StatusValue = {
    displayOrder?: number;
    id?: number;
    label?: {
        [key: string]: (string);
    };
    name?: string;
    notificationLevel?: 'statusUserOwner' | 'catalogueAdministrator' | 'catalogueProfileAdministrator' | 'catalogueProfileUserAdmin' | 'catalogueProfileReviewer' | 'catalogueProfileEditor' | 'catalogueProfileRegisteredUser' | 'catalogueProfileGuest' | 'recordProfileReviewer' | 'recordUserAuthor' | 'recordGroupEmail';
    reserved?: boolean;
    reserved_JpaWorkaround?: string;
    type?: 'workflow' | 'task' | 'event';
};

export type notificationLevel = 'statusUserOwner' | 'catalogueAdministrator' | 'catalogueProfileAdministrator' | 'catalogueProfileUserAdmin' | 'catalogueProfileReviewer' | 'catalogueProfileEditor' | 'catalogueProfileRegisteredUser' | 'catalogueProfileGuest' | 'recordProfileReviewer' | 'recordUserAuthor' | 'recordGroupEmail';

export type SuggestionType = {
    category?: string;
    id?: string;
    name: string;
    operational: string;
    params?: string;
    process?: string;
    target?: string;
};

export type SystemInfo = {
    buildDate?: string;
    buildJavaVendor?: string;
    buildJavaVersion?: string;
    buildOsInfo?: string;
    devMode?: boolean;
    scmRevision?: string;
    scmUrl?: string;
    stagingProfile?: string;
    subVersion?: string;
    version?: string;
};

/**
 * Thesaurus information
 */
export type ThesaurusInfo = {
    defaultNamespace?: string;
    description?: string;
    dname?: string;
    filename?: string;
    multilingualDescriptions?: {
        [key: string]: (string);
    };
    multilingualTitles?: {
        [key: string]: (string);
    };
    title?: string;
    type?: string;
};

export type Thumbnail = {
    item?: Array<RelatedThumbnailItem>;
};

export type TransferRequest = {
    sourceGroup?: number;
    sourceUser?: number;
    targetGroup?: number;
    targetUser?: number;
};

export type Translations = {
    fieldName?: string;
    id?: number;
    langId?: string;
    value?: string;
};

export type UiSetting = {
    configuration?: string;
    id?: string;
};

export type User = {
    accountNonExpired?: boolean;
    accountNonLocked?: boolean;
    addresses?: Array<Address>;
    authorities?: Array<GrantedAuthority>;
    credentialsNonExpired?: boolean;
    email?: string;
    emailAddresses?: Array<(string)>;
    enabled?: boolean;
    id?: number;
    kind?: string;
    lastLoginDate?: string;
    name?: string;
    organisation?: string;
    primaryAddress?: Address;
    profile?: 'Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor';
    security?: UserSecurity;
    surname?: string;
    username?: string;
};

export type profile = 'Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor';

export type UserDto = {
    addresses?: Array<Address>;
    email?: UserDto;
    emailAddresses?: Array<(string)>;
    enabled?: boolean;
    groupsEditor?: Array<(string)>;
    groupsRegisteredUser?: Array<(string)>;
    groupsReviewer?: Array<(string)>;
    groupsUserAdmin?: Array<(string)>;
    id?: string;
    kind?: string;
    name?: string;
    organisation?: string;
    password?: string;
    profile?: string;
    surname?: string;
    username?: string;
};

export type UserFeedbackDTO = {
    approverName?: string;
    authorEmail?: string;
    authorName?: string;
    authorOrganization?: string;
    authorUserId?: number;
    captcha?: string;
    comment?: string;
    date?: string;
    keywords?: Array<(string)>;
    metadataTitle?: string;
    metadataUUID?: string;
    optionPrivacy?: boolean;
    parentUuid?: string;
    published?: boolean;
    rating?: {
        [key: string]: (number);
    };
    ratingAVG?: number;
    showApproveButton?: boolean;
    uuid?: string;
};

export type UserGroup = {
    group?: Group;
    id?: UserGroupId;
    profile?: 'Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor';
    user?: User;
};

export type UserGroupId = {
    groupId?: number;
    profile?: 'Administrator' | 'UserAdmin' | 'Reviewer' | 'Editor' | 'RegisteredUser' | 'Guest' | 'Monitor';
    userId?: number;
};

export type UserGroupsResponse = {
    groupId?: number;
    groupName?: string;
    userId?: number;
    userName?: string;
    userProfile?: string;
};

/**
 * User details
 */
export type UserRegisterDto = {
    address?: Address;
    captcha?: string;
    email?: string;
    name?: string;
    organisation?: string;
    profile?: string;
    surname?: string;
    username?: string;
};

/**
 * User search details
 */
export type UserSearchDto = {
    creationDate?: string;
    creator?: string;
    creatorId?: number;
    featuredType?: string;
    groups?: Array<(number)>;
    id?: number;
    logo?: string;
    names?: {
        [key: string]: (string);
    };
    url?: string;
};

export type UserSecurity = {
    authType?: string;
    nodeId?: string;
    securityNotifications?: Array<('UPDATE_HASH_REQUIRED' | 'UNKNOWN')>;
    securityNotificationsString?: UserSecurity;
};

export type ValidationReport = {
    displayPriority: number;
    error: number;
    id: string;
    label: string;
    patterns: Patterns;
    requirement: string;
    schematronVerificationError?: string;
    success: string;
    total: string;
};

export type Values = {
    code?: string;
    definition?: string;
    label?: string;
};

export type XsltMetadataProcessingReport = {
    ellapsedTimeInSeconds?: number;
    endIsoDateTime?: string;
    errors?: Array<Report>;
    infos?: Array<InfoReport>;
    metadata?: Array<(number)>;
    metadataErrors?: {
        [key: string]: Array<Report>;
    };
    metadataInfos?: {
        [key: string]: Array<InfoReport>;
    };
    noProcessFoundCount?: number;
    numberOfNullRecords?: number;
    numberOfRecordNotFound?: number;
    numberOfRecords?: number;
    numberOfRecordsNotEditable?: number;
    numberOfRecordsProcessed?: number;
    numberOfRecordsUnchanged?: number;
    numberOfRecordsWithErrors?: number;
    processId?: string;
    running?: boolean;
    startIsoDateTime?: string;
    totalRecords?: number;
    totalTimeInSeconds?: number;
    type?: string;
    uuid?: string;
};

export type DescribeResourceData = {
    /**
     * fileIdentifier
     */
    fileIdentifier?: string;
    /**
     * spatial_dataset_identifier_code
     */
    spatialDatasetIdentifierCode?: string;
    /**
     * spatial_dataset_identifier_namespace
     */
    spatialDatasetIdentifierNamespace?: string;
};

export type DescribeResourceResponse = unknown | void;

export type DescribeData = {
    /**
     * metadataUuid
     */
    metadataUuid: string;
};

export type DescribeResponse = unknown | void;

export type DownloadResourceData = {
    /**
     * crs
     */
    crs: string;
    /**
     * spatial_dataset_identifier_code
     */
    spatialDatasetIdentifierCode: string;
    /**
     * spatial_dataset_identifier_namespace
     */
    spatialDatasetIdentifierNamespace: string;
};

export type DownloadResourceResponse = unknown | void;

export type FeedsData = {
    /**
     * fileIdentifier
     */
    fileIdentifier?: string;
};

export type FeedsResponse = {
    [key: string]: unknown;
};

export type ScanResponse = {
    [key: string]: unknown;
};

export type GetCssStyleResponse = {
    [key: string]: (string);
};

export type SaveCssStyleData = {
    requestBody: string;
};

export type SaveCssStyleResponse = string;

export type ListFormattersData = {
    id?: string;
    pluginOnly?: boolean;
    publishedOnly?: boolean;
    schema?: string;
    uuid?: string;
};

export type ListFormattersResponse = FormatterDataResponse;

export type AddFormatterData = {
    file: Array<((Blob | File))>;
};

export type AddFormatterResponse = unknown;

export type ClearFormatterCacheResponse = void;

export type DeleteFormatterData = {
    formatter: string;
    schema: string;
};

export type DeleteFormatterResponse = void;

export type DownloadFormatterData = {
    formatter: string;
    schema: string;
};

export type DownloadFormatterResponse = unknown;

export type GetFormatterFilesData = {
    formatter: string;
    schema: string;
};

export type GetFormatterFilesResponse = string;

export type GetFormatterFileContentData = {
    file: string;
    formatter: string;
    schema: string;
};

export type GetFormatterFileContentResponse = string;

export type UpdateFormatterFileData = {
    data: string;
    file: string;
    formatter: string;
    schema: string;
};

export type UpdateFormatterFileResponse = unknown;

export type GetGroupsData = {
    /**
     * For a specific profile
     */
    profile?: string;
    /**
     * Including Internet, Intranet, Guest groups or not
     */
    withReservedGroup?: boolean;
};

export type GetGroupsResponse = Array<Group>;

export type AddGroupData = {
    requestBody: Group;
};

export type AddGroupResponse = number;

export type DeleteGroupData = {
    /**
     * Force removal even if records are assigned to that group.
     */
    force?: boolean;
    /**
     * Group identifier.
     */
    groupIdentifier: number;
};

export type DeleteGroupResponse = void;

export type GetGroupData = {
    /**
     * Group identifier
     */
    groupIdentifier: number;
};

export type GetGroupResponse = Group;

export type UpdateGroupData = {
    /**
     * Group identifier
     */
    groupIdentifier: number;
    requestBody: Group;
};

export type UpdateGroupResponse = void;

export type GetGroupUsersData = {
    /**
     * Group identifier
     */
    groupIdentifier: number;
};

export type GetGroupUsersResponse = Array<User>;

export type GetGroupLogoData = {
    /**
     * Group identifier
     */
    groupId: number;
};

export type GetGroupLogoResponse = unknown;

export type CheckHarvesterPropertyExistData = {
    /**
     * The value to search
     */
    exist: string;
    /**
     * The harvester property to check
     */
    property: string;
};

export type CheckHarvesterPropertyExistResponse = 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';

export type AssignHarvestedRecordToSourceData = {
    /**
     * The harvester UUID
     */
    harvesterUuid: string;
    /**
     * The target source UUID
     */
    source: string;
};

export type AssignHarvestedRecordToSourceResponse = 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';

export type CleanTranslationsPackagesCacheResponse = unknown;

export type GetTranslationsData = {
    type?: Array<(string)>;
};

export type GetTranslationsResponse = {
    [key: string]: (string);
};

export type GetCustomTranslationsData = {
    type?: Array<(string)>;
};

export type GetCustomTranslationsResponse = Array<Translations>;

export type RemoveAllTranslationsResponse = unknown;

export type GetDbTranslationsResponse = {
    [key: string]: (string);
};

export type AddTranslationsData = {
    replace?: boolean;
    requestBody: Array<Translations>;
};

export type AddTranslationsResponse = string;

export type DeleteTranslationsData = {
    /**
     * Untranslated key for which all translations will be deleted.
     */
    key: string;
};

export type DeleteTranslationsResponse = unknown;

export type AddTranslationsForData = {
    /**
     * Untranslated key for which translations are provided.
     */
    key: string;
    /**
     * Set to `true` to erase all existing translations for that key
     */
    replace?: boolean;
    /**
     * An object where keys are valid 3-letter language codes (e.g. `eng` or `fre`) and values are custom translations for the corresponding language.
     */
    requestBody: {
        [key: string]: (string);
    };
};

export type AddTranslationsForResponse = string;

export type GetTranslationsPackagesResponse = {
    [key: string]: Array<(string)>;
};

export type GetTranslationsPackageData = {
    pack: string;
};

export type GetTranslationsPackageResponse = {
    [key: string]: (string);
};

export type GetIdentifiersData = {
    /**
     * Only user defined ones
     */
    userDefinedOnly?: boolean;
};

export type GetIdentifiersResponse = Array<MetadataIdentifierTemplate>;

export type AddIdentifierData = {
    requestBody: MetadataIdentifierTemplate;
};

export type AddIdentifierResponse = number;

export type DeleteIdentifierData = {
    /**
     * Identifier template identifier
     */
    identifier: number;
};

export type DeleteIdentifierResponse = void;

export type UpdateIdentifierData = {
    /**
     * Identifier template identifier
     */
    identifier: number;
    requestBody: MetadataIdentifierTemplate;
};

export type UpdateIdentifierResponse = void;

export type GetIsoLanguagesResponse = Array<IsoLanguage>;

export type GetLanguagesResponse = Array<Language>;

export type GetApplicationLanguagesResponse = Array<Language>;

export type DeleteLanguageData = {
    /**
     * ISO 3 letter code
     */
    langCode: string;
};

export type DeleteLanguageResponse = void;

export type AddLanguagesData = {
    /**
     * ISO 3 letter code
     */
    langCode: string;
};

export type AddLanguagesResponse = unknown;

export type GetLogosResponse = Array<(string)>;

export type AddLogoData = {
    /**
     * The logo image to upload
     */
    file: Array<((Blob | File))>;
    /**
     * Overwrite if exists
     */
    overwrite?: boolean;
};

export type AddLogoResponse = string;

export type DeleteLogoData = {
    /**
     * The logo filename to delete
     */
    file: string;
};

export type DeleteLogoResponse = void;

export type GetLogoData = {
    /**
     * The logo filename
     */
    file: string;
};

export type GetLogoResponse = unknown;

export type GetMapserversResponse = Array<AnonymousMapserver>;

export type AddMapserverData = {
    requestBody: MapServer;
};

export type AddMapserverResponse = number;

export type DeleteMapserverData = {
    /**
     * Mapserver identifier
     */
    mapserverId: number;
};

export type DeleteMapserverResponse = void;

export type GetMapserverData = {
    /**
     * Mapserver identifier
     */
    mapserverId: string;
};

export type UpdateMapserverData = {
    /**
     * Mapserver identifier
     */
    mapserverId: number;
    requestBody: MapServer;
};

export type UpdateMapserverResponse = void;

export type UpdateMapserverAuthData = {
    /**
     * Mapserver identifier
     */
    mapserverId: number;
    /**
     * Password
     */
    password: string;
    /**
     * User name
     */
    username: string;
};

export type UpdateMapserverAuthResponse = void;

export type DeleteMapserverResourceData = {
    /**
     * Mapserver identifier
     */
    mapserverId: string;
    /**
     * Metadata abstract
     */
    metadataAbstract?: string;
    /**
     * Metadata title
     */
    metadataTitle?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Resource name (could be a file or a db connection)
     */
    resource: string;
};

export type GetMapserverResourceData = {
    /**
     * Mapserver identifier
     */
    mapserverId: string;
    /**
     * Metadata abstract
     */
    metadataAbstract?: string;
    /**
     * Metadata title
     */
    metadataTitle?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Resource name (could be a file or a db connection)
     */
    resource: string;
};

export type PublishMapserverResourceData = {
    /**
     * Mapserver identifier
     */
    mapserverId: string;
    /**
     * Metadata abstract
     */
    metadataAbstract?: string;
    /**
     * Metadata title
     */
    metadataTitle?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Resource name (could be a file or a db connection)
     */
    resource: string;
};

export type GetMapservicesResponse = Array<MapService>;

export type GetMeResponse = MeResponse;

export type GetOperationsResponse = Array<Operation>;

export type ListPagesData = {
    format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
    language?: string;
    section?: 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3';
};

export type AddPageUploadingFileData = {
    format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
    formData?: {
        data: (Blob | File);
    };
    language: string;
    pageId: string;
    sections?: Array<('TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3')>;
    status?: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';
};

export type AddPageUploadingFileResponse = string;

export type AddPageWithoutUploadingFileData = {
    requestBody: PageProperties;
};

export type AddPageWithoutUploadingFileResponse = string;

export type GetPageFormatsResponse = Array<('LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT')>;

export type GetPageSectionsResponse = Array<('TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3')>;

export type GetPageStatusResponse = Array<('PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN')>;

export type DeletePageData = {
    language: string;
    pageId: string;
};

export type DeletePageResponse = unknown;

export type GetPageData = {
    language: string;
    pageId: string;
};

export type GetPageResponse = PageProperties;

export type UpdatePageData = {
    language: string;
    pageId: string;
    requestBody: PageProperties;
};

export type UpdatePageResponse = unknown;

export type GetPageContentData = {
    language: string;
    pageId: string;
};

export type GetPageContentResponse = string;

export type PreviewProcessSearchAndReplaceData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Return differences with diff, diffhtml or patch
     */
    diffType?: 'patch' | 'diff' | 'diffhtml';
    /**
     * regexpFlags
     */
    regexpFlags?: string;
    /**
     * Replacement
     */
    replace?: string;
    /**
     * Value to search for
     */
    search: string;
    /**
     * Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     */
    useRegexp?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type PreviewProcessSearchAndReplaceResponse = {
    [key: string]: unknown;
};

export type ProcessSearchAndReplaceData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Index after processing
     */
    index?: boolean;
    /**
     * regexpFlags
     */
    regexpFlags?: string;
    /**
     * Replacement
     */
    replace?: string;
    /**
     * Value to search for
     */
    search: string;
    /**
     * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     */
    updateDateStamp?: boolean;
    /**
     * Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     */
    useRegexp?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ProcessSearchAndReplaceResponse = XsltMetadataProcessingReport;

export type DeleteResponse = void;

export type GetProcessReportResponse = Array<ProcessingReport>;

export type SearchAndReplaceData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Case insensitive search.
     */
    isCaseInsensitive?: boolean;
    /**
     * Test only (ie. metadata are not saved). Return the report only.
     */
    isTesting?: boolean;
    process?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * 'record' to apply vacuum.xsl, 'element' to remove empty elements. Empty to not affect empty elements.
     */
    vacuumMode?: string;
};

export type SearchAndReplaceResponse = MetadataReplacementProcessingReport;

export type PreviewProcessRecordsData = {
    /**
     * Append documents before processing
     */
    appendFirst?: boolean;
    /**
     * Apply update fixed info
     */
    applyUpdateFixedInfo?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Return differences with diff, diffhtml or patch
     */
    diffType?: 'patch' | 'diff' | 'diffhtml';
    /**
     * Process identifier
     */
    process: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type PreviewProcessRecordsResponse = {
    [key: string]: unknown;
};

export type ProcessRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Index after processing
     */
    index?: boolean;
    /**
     * Process identifier
     */
    process: string;
    /**
     * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     */
    updateDateStamp?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ProcessRecordsResponse = XsltMetadataProcessingReport;

export type DeleteRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * Backup first the record as MEF in the metadata removed folder.
     */
    withBackup?: boolean;
};

export type DeleteRecordsResponse = SimpleMetadataProcessingReport;

export type GetAsRdfData = {
    /**
     * Search key
     */
    any?: string;
    /**
     * A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&createDateYear/2018&sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     */
    facetQ?: string;
    /**
     * Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     */
    from?: number;
    /**
     * Indicates the number of hits per page.
     */
    hitsPerPage?: number;
    /**
     * Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     */
    similarity?: number;
    /**
     * Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     */
    sortBy?: string;
    /**
     * Sort order. Possible values: reverse.
     */
    sortOrder?: string;
    /**
     * A search key for the title.
     */
    title?: string;
};

export type GetAsRdfResponse = unknown;

export type InsertFileData = {
    /**
     * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
     */
    allowEditGroupMembers?: boolean;
    /**
     * (MEF file only) Assign to current catalog.
     */
    assignToCatalog?: boolean;
    /**
     * Tags to assign to the record.
     */
    category?: Array<(string)>;
    /**
     * (experimental) Add extra information to the record.
     */
    extra?: string;
    /**
     * XML or MEF file to upload
     */
    file?: Array<((Blob | File))>;
    /**
     * The group the record is attached to.
     */
    group?: string;
    /**
     * The type of record.
     */
    metadataType?: 'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE';
    /**
     * (XML file only) Publish record.
     */
    publishToAll?: boolean;
    /**
     * Validate the record first and reject it if not valid.
     */
    rejectIfInvalid?: boolean;
    /**
     * Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     */
    schema?: string;
    /**
     * XSL transformation to apply to the record.
     */
    transformWith?: string;
    /**
     * Record identifier processing.
     */
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE';
};

export type InsertFileResponse = SimpleMetadataProcessingReport;

export type InsertData = {
    /**
     * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
     */
    allowEditGroupMembers?: boolean;
    /**
     * (MEF file only) Assign to current catalog.
     */
    assignToCatalog?: boolean;
    /**
     * Tags to assign to the record.
     */
    category?: Array<(string)>;
    /**
     * (experimental) Add extra information to the record.
     */
    extra?: string;
    /**
     * The group the record is attached to.
     */
    group?: string;
    /**
     * The type of record.
     */
    metadataType?: 'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE';
    /**
     * (XML file only and if workflow is not enabled) Publish record.
     */
    publishToAll?: boolean;
    /**
     * (Server folder import only) Recursive search in folder.
     */
    recursiveSearch?: boolean;
    /**
     * Validate the record first and reject it if not valid.
     */
    rejectIfInvalid?: boolean;
    requestBody?: string;
    /**
     * Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     */
    schema?: string;
    /**
     * Server folder where to look for files.
     */
    serverFolder?: string;
    /**
     * XSL transformation to apply to the record.
     */
    transformWith?: string;
    /**
     * URL of a file to download and insert.
     */
    url?: Array<(string)>;
    /**
     * Record identifier processing.
     */
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE';
};

export type InsertResponse = SimpleMetadataProcessingReport;

export type ApproveData = {
    requestBody: MetadataBatchApproveParameter;
};

export type ApproveResponse = MetadataProcessingReport;

export type TriggerResponse = string;

export type BatchEditData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    requestBody: Array<BatchEditParameter>;
    /**
     * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     */
    updateDateStamp?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type BatchEditResponse = IProcessingReport;

export type PreviewBatchEditData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Return differences with diff, diffhtml or patch
     */
    diffType?: 'patch' | 'diff' | 'diffhtml';
    requestBody: Array<BatchEditParameter>;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type PreviewBatchEditResponse = {
    [key: string]: unknown;
};

export type ExportAsCsvData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Multiple values separator
     */
    internalSep?: string;
    /**
     * XPath pointing to the XML element to loop on.
     */
    loopElementXpath?: string;
    /**
     * Properties to collect
     */
    propertiesXpath?: Array<(string)>;
    /**
     * Column separator
     */
    sep?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ExportAsCsvResponse = unknown;

export type CreateData = {
    /**
     * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
     */
    allowEditGroupMembers?: boolean;
    /**
     * Tags to assign to the record.
     */
    category?: Array<(string)>;
    /**
     * The group the record is attached to.
     */
    group: string;
    /**
     * Copy attachments from source?
     */
    hasAttachmentsOfSource?: boolean;
    /**
     * Copy categories from source?
     */
    hasCategoryOfSource?: boolean;
    /**
     * Is child of the record to copy?
     */
    isChildOfSource?: boolean;
    /**
     * The type of record.
     */
    metadataType?: 'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE';
    /**
     * UUID of the source record to copy.
     */
    sourceUuid: string;
    /**
     * Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     */
    targetUuid?: string;
};

export type CreateResponse = string;

export type InsertOgcMapContextFileData = {
    /**
     * OGC OWS context file name
     */
    filename?: string;
    /**
     * The group the record is attached to.
     */
    group?: string;
    /**
     * Map overview as PNG (base64 encoded)
     */
    overview?: string;
    /**
     * Map overview filename
     */
    overviewFilename?: string;
    /**
     * Publish record.
     */
    publishToAll?: boolean;
    /**
     * A map abstract
     */
    recordAbstract?: string;
    /**
     * A map title
     */
    title: string;
    /**
     * Topic category
     */
    topic?: string;
    /**
     * OGC OWS context URL
     */
    url?: string;
    /**
     * Record identifier processing.
     */
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE';
    /**
     * A map viewer URL to visualize the map
     */
    viewerUrl?: string;
    /**
     * OGC OWS context as string
     */
    xml?: string;
};

export type InsertOgcMapContextFileResponse = SimpleMetadataProcessingReport;

export type IndexData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type IndexResponse2 = IndexResponse;

export type PurgeAllResponse = unknown;

export type GetRecordLinksData = {
    /**
     * Optional, filter links excluding harvested metadata.
     */
    excludeHarvestedMetadataFilter?: boolean;
    /**
     * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
     */
    filter?: LinkFilter;
    /**
     * Optional, filter links to records published in that group.
     */
    groupIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to records created in that group.
     */
    groupOwnerIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to http status.
     */
    httpErrorStatusValueFilter?: Array<(number)>;
    /**
     * Results page you want to retrieve (0..N)
     */
    page?: number;
    /**
     * Number of records per page.
     */
    size?: number;
    /**
     * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     */
    sort?: string;
};

export type GetRecordLinksResponse = PageLink;

export type GetRecordLinksPostData = {
    /**
     * Optional, filter links excluding harvested metadata.
     */
    excludeHarvestedMetadataFilter?: boolean;
    /**
     * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
     */
    filter?: LinkFilter;
    /**
     * Optional, filter links to records published in that group.
     */
    groupIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to records created in that group.
     */
    groupOwnerIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to http status.
     */
    httpStatusValueFilter?: Array<(number)>;
    /**
     * Results page you want to retrieve (0..N)
     */
    page?: number;
    /**
     * Number of records per page.
     */
    size?: number;
    /**
     * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     */
    sort?: string;
};

export type GetRecordLinksPostResponse = PageLink;

export type AnalyzeRecordLinksData = {
    analyze?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Only allowed if Administrator.
     */
    removeFirst?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type AnalyzeRecordLinksResponse = SimpleMetadataProcessingReport;

export type AnalyzeLinksData = {
    /**
     * URL
     */
    url?: Array<(string)>;
};

export type AnalyzeLinksResponse = unknown;

export type GetRecordLinksAsCsvData = {
    /**
     * Optional, filter links excluding harvested metadata.
     */
    excludeHarvestedMetadataFilter?: boolean;
    /**
     * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
     */
    filter?: LinkFilter;
    /**
     * Optional, filter links to records published in that group.
     */
    groupIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to records created in that group.
     */
    groupOwnerIdFilter?: Array<(number)>;
    /**
     * Optional, filter links to http status.
     */
    httpStatusValueFilter?: Array<(number)>;
    /**
     * Results page you want to retrieve (0..N)
     */
    page?: number;
    /**
     * Number of records per page.
     */
    size?: number;
    /**
     * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     */
    sort?: string;
};

export type GetRecordLinksAsCsvResponse = unknown;

export type SetGroupAndOwnerData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Group identifier
     */
    groupIdentifier: number;
    /**
     * User identifier
     */
    userIdentifier: number;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type SetGroupAndOwnerResponse = MetadataProcessingReport;

export type ExportAsPdfData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ExportAsPdfResponse = unknown;

export type PublishMultipleRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Publication type
     */
    publicationType: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type PublishMultipleRecordsResponse = MetadataProcessingReport;

export type AddSamplesData = {
    /**
     * Schema identifiers
     */
    schema: Array<(string)>;
};

export type AddSamplesResponse = SimpleMetadataProcessingReport;

export type GetSharingSettingsResponse = SharingResponse;

export type ShareMultipleRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    requestBody: SharingParameter;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ShareMultipleRecordsResponse = MetadataProcessingReport;

export type GetPublicationOptionsResponse = Array<PublicationOption>;

export type GetWorkflowStatusByTypeData = {
    /**
     * One or more event author. Default is all.
     */
    author?: Array<(number)>;
    /**
     * Start date
     */
    dateFrom?: string;
    /**
     * End date
     */
    dateTo?: string;
    /**
     * All event details including XML changes. Responses are bigger. Default is false
     */
    details?: boolean;
    /**
     * From page
     */
    from?: number;
    /**
     * One or more record identifier. Default is all.
     */
    id?: Array<(number)>;
    /**
     * One or more event owners. Default is all.
     */
    owner?: Array<(number)>;
    /**
     * One or more metadata record identifier. Default is all.
     */
    recordIdentifier?: Array<(number)>;
    /**
     * Number of records to return
     */
    size?: number;
    /**
     * Sort Order (ie. DESC or ASC). Default is none.
     */
    sortOrder?: 'ASC' | 'DESC';
    /**
     * One or more status id. Default is all.
     */
    statusIds?: Array<(string)>;
    /**
     * One or more types to retrieve (ie. worflow, event, task). Default is all.
     */
    type?: Array<('workflow' | 'task' | 'event')>;
    /**
     * One or more metadata uuid. Default is all.
     */
    uuid?: Array<(string)>;
};

export type GetWorkflowStatusByTypeResponse = Array<MetadataStatusResponse>;

export type SubmitData = {
    requestBody: MetadataBatchSubmitParameter;
};

export type SubmitResponse = MetadataProcessingReport;

export type DeleteTagForRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Tag identifier
     */
    id: Array<(number)>;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type DeleteTagForRecordsResponse = MetadataProcessingReport;

export type TagRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Clear all before adding new ones
     */
    clear?: boolean;
    /**
     * Tag identifier
     */
    id?: Array<(number)>;
    /**
     * Tag identifier to remove.
     */
    removeId?: Array<(number)>;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type TagRecordsResponse = MetadataProcessingReport;

export type AddTemplatesData = {
    /**
     * Schema identifiers
     */
    schema: Array<(string)>;
};

export type AddTemplatesResponse = SimpleMetadataProcessingReport;

export type UnpublishMultipleRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Publication type
     */
    publicationType: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type UnpublishMultipleRecordsResponse = MetadataProcessingReport;

export type CleanValidationStatusData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type CleanValidationStatusResponse = SimpleMetadataProcessingReport;

export type ValidateRecordsData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ValidateRecordsResponse = SimpleMetadataProcessingReport;

export type ValidateRecordsInspireData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     */
    mode?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type ValidateRecordsInspireResponse = string;

export type EnableVersionControlForRecordsData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
};

export type EnableVersionControlForRecordsResponse = MetadataProcessingReport;

export type ExportAsMefData = {
    addSchemaLocation?: boolean;
    /**
     * Download the approved version
     */
    approved?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * MEF file format.
     */
    format?: 'SIMPLE' | 'PARTIAL' | 'FULL';
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * With related records (parent and service).
     */
    withRelated?: boolean;
    /**
     * Preserve XLink URLs in the records.
     */
    withXlinkAttribute?: boolean;
    /**
     * Resolve XLinks in the records.
     */
    withXlinksResolved?: boolean;
};

export type ExportAsMefResponse = unknown;

export type DeleteRecordData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Backup first the record as MEF in the metadata removed folder.
     */
    withBackup?: boolean;
};

export type DeleteRecordResponse = void;

export type GetRecordData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetRecordResponse = (Blob | File);

export type SendEmailToContactData = {
    /**
     * User function.
     */
    _function?: string;
    /**
     * Comment category.
     */
    category?: string;
    /**
     * A comment or question.
     */
    comments: string;
    /**
     * User email address.
     */
    email: string;
    /**
     * List of record's contact to send this email (separated by comma).
     */
    metadataEmail?: string;
    /**
     * Metadata record UUID.
     */
    metadataUuid: string;
    /**
     * User name.
     */
    name: string;
    /**
     * User organisation.
     */
    org: string;
    /**
     * User phone number.
     */
    phone?: string;
    /**
     * Recaptcha validation key.
     */
    recaptcha?: string;
    /**
     * Email subject.
     */
    subject?: string;
    /**
     * Comment type.
     */
    type?: string;
};

export type SendEmailToContactResponse = string;

export type GetAssociatedResourcesData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Number of rows returned. Default 100.
     */
    rows?: number;
    /**
     * Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     */
    start?: number;
    /**
     * Type of related resource. If none, all resources are returned.
     */
    type?: Array<RelatedItemType>;
};

export type GetAssociatedResourcesResponse = {
    [key: string]: Array<AssociatedRecord>;
};

export type DelResourcesData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
};

export type DelResourcesResponse = void;

export type GetAllResourcesData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    filter?: string;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    /**
     * Sort by
     */
    sort?: 'type' | 'name';
};

export type GetAllResourcesResponse = Array<MetadataResource>;

export type PutResourceData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    requestBody?: {
        /**
         * The file to upload
         */
        file: (Blob | File);
    };
    /**
     * The sharing policy
     */
    visibility?: 'PUBLIC' | 'PRIVATE';
};

export type PutResourceResponse = MetadataResource;

export type PutResourceFromUrlData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    /**
     * The URL to load in the store
     */
    url: string;
    /**
     * The sharing policy
     */
    visibility?: 'PUBLIC' | 'PRIVATE';
};

export type PutResourceFromUrlResponse = MetadataResource;

export type SaveThumbnailData = {
    /**
     * The mapprint module JSON configuration
     */
    jsonConfig: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * The rotation angle of the map
     */
    rotationAngle?: number;
};

export type SaveThumbnailResponse = MetadataResource;

export type DelResourceData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    /**
     * The resource identifier (ie. filename)
     */
    resourceId: string;
};

export type DelResourceResponse = void;

export type GetResourceData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    /**
     * The resource identifier (ie. filename)
     */
    resourceId: string;
    /**
     * Size (only applies to images). From 1px to 2048px.
     */
    size?: number;
};

export type GetResourceResponse = (Blob | File);

export type PatchResourceData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    /**
     * The resource identifier (ie. filename)
     */
    resourceId: string;
    /**
     * The visibility
     */
    visibility: 'PUBLIC' | 'PRIVATE';
};

export type PatchResourceResponse = MetadataResource;

export type UnregisterDoiData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type UnregisterDoiResponse = string;

export type CreateDoiData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type CreateDoiResponse = {
    [key: string]: (string);
};

export type CheckDoiUrlData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type CheckDoiUrlResponse = string;

export type CheckDoiStatusData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type CheckDoiStatusResponse = {
    [key: string]: (boolean);
};

export type CancelEditsData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type CancelEditsResponse = void;

export type StartEditingData = {
    /**
     * Tab
     */
    currTab?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    withAttributes?: boolean;
};

export type StartEditingResponse = unknown;

export type SaveEditsData = {
    /**
     * Save current edits.
     */
    commit?: boolean;
    /**
     * Record as XML. TODO: rename xml
     */
    data?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    minor?: boolean;
    /**
     * Submit for review directly after save.
     */
    status?: string;
    /**
     * Tab
     */
    tab?: string;
    /**
     * Save and terminate session.
     */
    terminate?: boolean;
    withAttributes?: boolean;
    withValidationErrors?: boolean;
};

export type SaveEditsResponse = unknown;

export type DeleteAttributeData = {
    /**
     * Should attributes be shown on the editor snippet?
     */
    displayAttributes?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Reference of the attribute to remove.
     */
    ref: string;
};

export type DeleteAttributeResponse = void;

export type DeleteElementData = {
    /**
     * Should attributes be shown on the editor snippet?
     */
    displayAttributes?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Name of the parent.
     */
    parent: string;
    /**
     * Reference of the element to remove.
     */
    ref: Array<(string)>;
};

export type DeleteElementResponse = void;

export type AddElementData = {
    /**
     * Use geonet:attribute for attributes or child name.
     */
    child?: string;
    /**
     * Should attributes be shown on the editor snippet?
     */
    displayAttributes?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Name of the element to add (with prefix)
     */
    name: string;
    /**
     * Reference of the insertion point.
     */
    ref: string;
};

export type AddElementResponse = unknown;

export type ReorderElementData = {
    /**
     * Direction
     */
    direction: Direction;
    /**
     * Should attributes be shown on the editor snippet?
     */
    displayAttributes?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Reference of the element to move.
     */
    ref: string;
};

export type ReorderElementResponse = unknown;

export type GetAllRecordExtentAsJsonData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetAllRecordExtentAsJsonResponse = Array<ExtentDto>;

export type GetAllRecordExtentAsImageData = {
    /**
     * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     */
    background?: string;
    /**
     * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     */
    fillColor?: string;
    /**
     * (optional) height of the image that is created. Only one of width and height are permitted
     */
    height?: number;
    /**
     * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
     */
    mapsrs?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     */
    strokeColor?: string;
    /**
     * (optional) width of the image that is created. Only one of width and height are permitted
     */
    width?: number;
};

export type GetAllRecordExtentAsImageResponse = Array<(string)>;

export type GetOneRecordExtentAsImageData = {
    /**
     * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     */
    background?: string;
    /**
     * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     */
    fillColor?: string;
    /**
     * Index of the geometry or bounding box to display. Starts at 1.
     */
    geometryIndex: number;
    /**
     * (optional) height of the image that is created. Only one of width and height are permitted
     */
    height?: number;
    /**
     * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
     */
    mapsrs?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     */
    strokeColor?: string;
    /**
     * (optional) width of the image that is created. Only one of width and height are permitted
     */
    width?: number;
};

export type GetOneRecordExtentAsImageResponse = Array<(string)>;

export type GetFeatureCatalogData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetFeatureCatalogResponse = FeatureResponse;

export type GetRecordAsJsonData = {
    /**
     * Add XSD schema location based on standard configuration (see schema-ident.xml).
     */
    addSchemaLocation?: boolean;
    /**
     * Download the approved version
     */
    approved?: boolean;
    /**
     * Download as a file
     */
    attachment?: boolean;
    /**
     * Increase record popularity
     */
    increasePopularity?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Add geonet:info details
     */
    withInfo?: boolean;
};

export type GetRecordAsJsonResponse = (Blob | File);

export type GetRecordAsXmlData = {
    /**
     * Add XSD schema location based on standard configuration (see schema-ident.xml).
     */
    addSchemaLocation?: boolean;
    /**
     * Download the approved version
     */
    approved?: boolean;
    /**
     * Download as a file
     */
    attachment?: boolean;
    /**
     * Increase record popularity
     */
    increasePopularity?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Add geonet:info details
     */
    withInfo?: boolean;
};

export type GetRecordAsXmlResponse = (Blob | File);

export type GetRecordAsZipData = {
    addSchemaLocation?: boolean;
    /**
     * Download the approved version
     */
    approved?: boolean;
    /**
     * MEF file format.
     */
    format?: 'SIMPLE' | 'PARTIAL' | 'FULL';
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * With related records (parent and service).
     */
    withRelated?: boolean;
    /**
     * Preserve XLink URLs in the records.
     */
    withXlinkAttribute?: boolean;
    /**
     * Resolve XLinks in the records.
     */
    withXlinksResolved?: boolean;
};

export type GetRecordAsZipResponse = unknown;

export type GetRecordFormattedByData = {
    /**
     * Download the approved version
     */
    approved?: boolean;
    /**
     * Formatter type to use.
     */
    formatterId: string;
    /**
     * Optional language ISO 3 letters code to override HTTP Accept-language header.
     */
    language?: string;
    mdpath?: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf';
    width?: '_25' | '_50' | '_75' | '_100';
};

export type GetRecordFormattedByResponse = unknown;

export type SetRecordGroupData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    requestBody: number;
};

export type SetRecordGroupResponse = void;

export type SetRecordOwnershipData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Group identifier
     */
    groupIdentifier: number;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * User identifier
     */
    userIdentifier: number;
};

export type SetRecordOwnershipResponse = MetadataProcessingReport;

export type GetRecordPermalinkData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetRecordPermalinkResponse = string;

export type GetRecordPopularityData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetRecordPopularityResponse = string;

export type IncreaseRecordPopularityData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type IncreaseRecordPopularityResponse = string;

export type GetSuggestionsData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetSuggestionsResponse = Array<SuggestionType>;

export type ProcessRecordPreviewData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Process identifier
     */
    process: string;
};

export type ProcessRecordPreviewResponse = unknown;

export type ProcessRecordData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Process identifier
     */
    process: string;
};

export type ProcessRecordResponse = string;

export type PublishData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Publication type
     */
    publicationType: string;
};

export type PublishResponse = void;

export type GetSavedQueriesData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetSavedQueriesResponse = Array<SavedQuery>;

export type ApplyQueryData = {
    /**
     * The metadata UUID
     */
    metadataUuid: string;
    requestBody?: {
        [key: string]: (string);
    };
    /**
     * The saved query to apply
     */
    savedQuery: string;
};

export type ApplyQueryResponse = {
    [key: string]: (string);
};

export type RateRecordData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    requestBody: number;
};

export type RateRecordResponse = number;

export type GetRelatedResourcesData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Number of rows returned. Default 100.
     */
    rows?: number;
    /**
     * Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     */
    start?: number;
    /**
     * Type of related resource. If none, all resources are returned.
     */
    type?: Array<RelatedItemType>;
};

export type GetRelatedResourcesResponse = RelatedResponse;

export type GetRecordSharingSettingsData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetRecordSharingSettingsResponse = SharingResponse;

export type ShareData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    requestBody: SharingParameter;
};

export type ShareResponse = void;

export type DeleteAllRecordStatusData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type DeleteAllRecordStatusResponse = void;

export type GetRecordStatusHistoryData = {
    details?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Sort direction
     */
    sortOrder?: 'ASC' | 'DESC';
};

export type GetRecordStatusHistoryResponse = Array<MetadataStatusResponse>;

export type SetStatusData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    requestBody: MetadataStatusParameter;
};

export type SetStatusResponse = {
    [key: string]: ('UPDATED' | 'UNCHANGED' | 'DELETED');
};

export type GetStatusData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetStatusResponse = MetadataWorkflowStatusResponse;

export type DeleteRecordStatusData = {
    /**
     * Change date
     */
    changeDate: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Status identifier
     */
    statusId: number;
    /**
     * User identifier
     */
    userId: number;
};

export type DeleteRecordStatusResponse = void;

export type ShowStatusAfterData = {
    /**
     * Change date
     */
    changeDate: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Status identifier
     */
    statusId: number;
    /**
     * User identifier
     */
    userId: number;
};

export type ShowStatusAfterResponse = string;

export type ShowStatusBeforeData = {
    /**
     * Change date
     */
    changeDate: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Status identifier
     */
    statusId: number;
    /**
     * User identifier
     */
    userId: number;
};

export type ShowStatusBeforeResponse = string;

export type CloseTaskData = {
    /**
     * Change date
     */
    changeDate: string;
    /**
     * Close date
     */
    closeDate: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Status identifier
     */
    statusId: number;
    /**
     * User identifier
     */
    userId: number;
};

export type CloseTaskResponse = void;

export type RestoreAtStatusSaveData = {
    /**
     * Change date
     */
    changeDate: string;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Status identifier
     */
    statusId: number;
    /**
     * User identifier
     */
    userId: number;
};

export type RestoreAtStatusSaveResponse = unknown;

export type GetRecordStatusHistoryByTypeData = {
    details?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Sort direction
     */
    sortOrder?: 'ASC' | 'DESC';
    /**
     * Type
     */
    type: 'workflow' | 'task' | 'event';
};

export type GetRecordStatusHistoryByTypeResponse = Array<MetadataStatusResponse>;

export type DeleteTagsData = {
    /**
     * Tag identifier. If none, all tags are removed.
     */
    id?: Array<(number)>;
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type DeleteTagsResponse = void;

export type GetRecordTagsData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetRecordTagsResponse = Array<MetadataCategory>;

export type TagRecordData = {
    /**
     * Clear all before adding new ones
     */
    clear?: boolean;
    /**
     * Tag identifier
     */
    id: Array<(number)>;
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type TagRecordResponse = unknown;

export type UnpublishData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Publication type
     */
    publicationType: string;
};

export type UnpublishResponse = void;

export type GetUserCommentsOnArecordData = {
    /**
     * Metadata record UUID.
     */
    metadataUuid: string;
    /**
     * Maximum number of feedback to return.
     */
    size?: number;
};

export type GetUserCommentsOnArecordResponse = Array<UserFeedbackDTO>;

export type GetMetadataRatingData = {
    /**
     * Metadata record UUID.
     */
    metadataUuid: string;
};

export type GetMetadataRatingResponse = RatingAverage;

export type ValidateRecordForInspireData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
    /**
     * Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     */
    mode?: string;
    /**
     * Test suite to run
     */
    testsuite: string;
};

export type ValidateRecordForInspireResponse = string;

export type GetTestSuitesData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type GetTestSuitesResponse = {
    [key: string]: Array<(string)>;
};

export type ValidateRecordData = {
    /**
     * Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     */
    isvalid?: boolean;
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type ValidateRecordResponse = Reports;

export type EnableVersionControlData = {
    /**
     * Record UUID.
     */
    metadataUuid: string;
};

export type EnableVersionControlResponse = string;

export type CheckValidationData = {
    /**
     * Test identifier
     */
    testId: string;
};

export type CheckValidationResponse = {
    [key: string]: (string);
};

export type GetRegionsData = {
    categoryId?: string;
    label?: string;
    maxRecords?: number;
};

export type GetRegionsResponse = ListRegionsResponse;

export type GetGeomAsImageData = {
    /**
     * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     */
    background?: string;
    /**
     * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     */
    fillColor?: string;
    /**
     * (optional) a wkt or gml encoded geometry.
     */
    geom?: string;
    geomsrs?: string;
    /**
     * (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
     */
    geomtype?: string;
    /**
     * (optional) height of the image that is created. Only one of width and height are permitted
     */
    height?: number;
    /**
     * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
     */
    mapsrs?: string;
    /**
     * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     */
    strokeColor?: string;
    /**
     * (optional) width of the image that is created. Only one of width and height are permitted
     */
    width?: number;
};

export type GetGeomAsImageResponse = Array<(string)>;

export type GetRegionTypesResponse = Array<Category>;

export type PreviewExtractedEntriesData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     */
    identifierXpath?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * XPath of the elements to extract as entry.
     */
    xpath: string;
};

export type PreviewExtractedEntriesResponse = {
    [key: string]: unknown;
};

export type ExtractEntriesData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     */
    identifierXpath?: string;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * XPath of the elements to extract as entry.
     */
    xpath: string;
};

export type ExtractEntriesResponse = {
    [key: string]: unknown;
};

export type ImportSpatialEntriesData = {
    /**
     * Attribute table charset
     */
    charset?: string;
    /**
     * Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     */
    descriptionAttribute?: string;
    formData?: {
        /**
         * The ZIP file to upload containing the Shapefile.
         */
        file: (Blob | File);
    };
    /**
     * geomProjectionTo
     */
    geomProjectionTo?: string;
    /**
     * The group the record is attached to.
     */
    group?: number;
    /**
     * lenient
     */
    lenient?: boolean;
    /**
     * Create only bounding box for each spatial objects.
     */
    onlyBoundingBox?: boolean;
    /**
     * Process
     */
    process?: string;
    /**
     * Schema identifier
     */
    schema?: string;
    /**
     * Attribute to use for UUID. If none, random UUID are generated.
     */
    uuidAttribute?: string;
    /**
     * Pattern to build UUID from. Default is '{{uuid}}'.
     */
    uuidPattern?: string;
    /**
     * Record identifier processing.
     */
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE' | 'REMOVE_AND_REPLACE';
};

export type ImportSpatialEntriesResponse = SimpleMetadataProcessingReport;

export type PreviewUpdatedRecordEntriesData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Filter query for directory search.
     */
    fq?: string;
    /**
     * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     */
    identifierXpath?: string;
    /**
     * List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
     */
    propertiesToCopy?: Array<(string)>;
    /**
     * Replace entry by XLink.
     */
    substituteAsXlink?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * XPath of the elements to extract as entry.
     */
    xpath: string;
};

export type PreviewUpdatedRecordEntriesResponse = {
    [key: string]: unknown;
};

export type UpdateRecordEntriesData = {
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Filter query for directory search.
     */
    fq?: string;
    /**
     * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     */
    identifierXpath?: string;
    /**
     * List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
     */
    propertiesToCopy?: Array<(string)>;
    /**
     * Replace entry by XLink.
     */
    substituteAsXlink?: boolean;
    /**
     * Record UUIDs. If null current selection is used.
     */
    uuids?: Array<(string)>;
    /**
     * XPath of the elements to extract as entry.
     */
    xpath: string;
};

export type UpdateRecordEntriesResponse = {
    [key: string]: unknown;
};

export type SearchCrsData = {
    /**
     * Search value
     */
    q?: string;
    /**
     * Number of results. Default is: 100
     */
    rows?: number;
    /**
     * Type of CRS
     */
    type?: 'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS';
};

export type SearchCrsResponse = Array<Crs>;

export type GetCrsTypesResponse = Array<('CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS')>;

export type GetCrsData = {
    /**
     * CRS identifier
     */
    id: string;
};

export type GetCrsResponse = Crs;

export type GetEntryData = {
    /**
     * lang
     */
    lang?: Array<(string)>;
    /**
     * Process
     */
    process?: Array<(string)>;
    /**
     * schema
     */
    schema?: string;
    /**
     * Transformation
     */
    transformation?: string;
    /**
     * Directory entry UUID.
     */
    uuid: string;
};

export type GetEntryResponse = unknown;

export type UploadThesaurusData = {
    /**
     * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     */
    dir?: string;
    requestBody?: {
        /**
         * If set, do a file upload.
         */
        file?: (Blob | File);
    };
    /**
     * XSL to be use to convert the thesaurus before load. Default _none_.
     */
    stylesheet?: string;
    /**
     * Local or external (default).
     */
    type?: 'external' | 'local';
};

export type UploadThesaurusResponse = string;

export type UploadThesaurusFromUrlData = {
    /**
     * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     */
    dir?: string;
    /**
     * Languages to download from a registry.
     */
    registryLanguage?: Array<(string)>;
    /**
     * If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     */
    registryType?: 're3gistry' | 'ldRegistry';
    /**
     * If set, try to download from a registry.
     */
    registryUrl?: string;
    requestBody?: ThesaurusInfo;
    /**
     * XSL to be use to convert the thesaurus before load. Default _none_.
     */
    stylesheet?: string;
    /**
     * Local or external (default).
     */
    type?: 'external' | 'local';
    /**
     * If set, try to download from the Internet.
     */
    url?: string;
};

export type UploadThesaurusFromUrlResponse = string;

export type ImportCsvAsThesaurusData = {
    /**
     * Column name for broader concept id. Default is broader.
     */
    conceptBroaderIdColumn?: string;
    /**
     * Column name for concept description. Default is description.
     */
    conceptDescriptionColumn?: string;
    /**
     * Column name for concept id. Default is id.
     */
    conceptIdColumn?: string;
    /**
     * Column name for concept label. Default is label.
     */
    conceptLabelColumn?: string;
    /**
     * Separator used when multiple broader/narrower/related ids are in the same column. Default is '|'.
     */
    conceptLinkSeparator?: string;
    /**
     * Column name for narrower concept id. Default is narrower.
     */
    conceptNarrowerIdColumn?: string;
    /**
     * Column name for related concept id. Default is related.
     */
    conceptRelatedIdColumn?: string;
    /**
     * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     */
    dir?: string;
    /**
     * Encoding. Default is UTF-8.
     */
    encoding?: string;
    /**
     * Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     */
    importAsThesaurus?: boolean;
    /**
     * Thesaurus languages
     */
    languages?: Array<(string)>;
    requestBody?: {
        /**
         * If set, do a file upload.
         */
        file?: (Blob | File);
    };
    /**
     * Thesaurus namespace. Default is filename.
     */
    thesaurusNs?: string;
    /**
     * Thesaurus title. Default is filename.
     */
    thesaurusTitle?: string;
    /**
     * Local or external (default).
     */
    type?: 'external' | 'local';
};

export type ImportCsvAsThesaurusResponse = unknown;

export type GetKeywordByIdData = {
    /**
     * Keyword identifier or list of keyword identifiers comma separated.
     */
    id: string;
    /**
     * Only print the keyword, no thesaurus information.
     */
    keywordOnly?: boolean;
    /**
     * Languages.
     */
    lang?: Array<(string)>;
    /**
     * langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
     */
    langMap?: string;
    /**
     * Thesaurus to look info for the keyword(s).
     */
    thesaurus: string;
    /**
     * XSL template to use (ISO19139 keyword by default, see convert.xsl).
     */
    transformation?: string;
};

export type GetKeywordByIdResponse = {
    [key: string]: unknown;
};

export type GetKeywordByIdsData = {
    /**
     * Keyword identifier or list of keyword identifiers comma separated.
     */
    id: string;
    /**
     * Only print the keyword, no thesaurus information.
     */
    keywordOnly?: boolean;
    /**
     * Languages.
     */
    lang?: Array<(string)>;
    /**
     * langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
     */
    langMap?: string;
    /**
     * Thesaurus to look info for the keyword(s).
     */
    thesaurus: string;
    /**
     * XSL template to use (ISO19139 keyword by default, see convert.xsl).
     */
    transformation?: string;
};

export type GetKeywordByIdsResponse = {
    [key: string]: unknown;
};

export type SearchKeywordsData = {
    /**
     * Query in that language
     */
    lang?: string;
    /**
     * Return keyword information in one or more languages
     */
    pLang?: Array<(string)>;
    /**
     * Query
     */
    q?: string;
    /**
     * Number of rows
     */
    rows?: number;
    /**
     * Sort by
     */
    sort?: string;
    /**
     * Start from
     */
    start?: number;
    /**
     * Thesaurus identifier
     */
    thesaurus?: Array<(string)>;
    /**
     * Type of search
     */
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH';
    /**
     * URI query
     */
    uri?: string;
};

export type SearchKeywordsResponse = {
    [key: string]: unknown;
};

export type DeleteThesaurusData = {
    /**
     * Thesaurus to delete.
     */
    thesaurus: string;
};

export type DeleteThesaurusResponse = unknown;

export type GetThesaurusData = {
    /**
     * Thesaurus to download.
     */
    thesaurus: string;
};

export type GetThesaurusResponse = (Blob | File);

export type UpdateThesaurusData = {
    requestBody: ThesaurusInfo;
    /**
     * Thesaurus to update.
     */
    thesaurus: string;
};

export type UpdateThesaurusResponse = unknown;

export type GetAssociatedResourcesForRecordsData = {
    /**
     * Use approved version or not
     */
    approved?: boolean;
    /**
     * Type of related resource. If none, all resources are returned.
     */
    type?: Array<RelatedItemType>;
    /**
     * Uuids of the metadatas you request the relations from.
     */
    uuid?: Array<(string)>;
};

export type GetAssociatedResourcesForRecordsResponse = {
    [key: string]: RelatedResponse;
};

export type GetReportDataDownloadsData = {
    /**
     * From date of the metadata downloads
     */
    dateFrom: string;
    /**
     * To date of the metadata downloads
     */
    dateTo: string;
    /**
     * Metadata group(s)
     */
    groups?: Array<(number)>;
};

export type GetReportDataDownloadsResponse = unknown;

export type GetReportDataUploadsData = {
    /**
     * From date of the metadata uploads
     */
    dateFrom: string;
    /**
     * To date of the metadata uploads
     */
    dateTo: string;
    /**
     * Metadata group(s)
     */
    groups?: Array<(number)>;
};

export type GetReportDataUploadsResponse = unknown;

export type GetReportInternalMetadataData = {
    /**
     * From date of metadata change date
     */
    dateFrom: string;
    /**
     * To date of metadata change date
     */
    dateTo: string;
    /**
     * Metadata group(s)
     */
    groups?: Array<(number)>;
};

export type GetReportInternalMetadataResponse = unknown;

export type GetReportUpdatedMetadataData = {
    /**
     * From date of metadata change date
     */
    dateFrom: string;
    /**
     * To date of metadata change date
     */
    dateTo: string;
    /**
     * Metadata group(s)
     */
    groups?: Array<(number)>;
};

export type GetReportUpdatedMetadataResponse = unknown;

export type GetActiveUsersData = {
    /**
     * From date of users login date
     */
    dateFrom: string;
    /**
     * To date of users login date
     */
    dateTo: string;
    /**
     * Group(s) for the users
     */
    groups?: Array<(number)>;
};

export type GetActiveUsersResponse = unknown;

export type GetRobotsTextResponse = unknown;

export type MsearchData = {
    bucket?: string;
    /**
     * Type of related resource. If none, no associated resource returned.
     */
    relatedType?: Array<RelatedItemType>;
    /**
     * JSON request based on Elasticsearch API.
     */
    requestBody: string;
};

export type MsearchResponse = string;

export type SearchData = {
    bucket?: string;
    /**
     * Type of related resource. If none, no associated resource returned.
     */
    relatedType?: Array<RelatedItemType>;
    /**
     * JSON request based on Elasticsearch API.
     */
    requestBody: estypes.SearchRequest;
};

export type SearchResponse = estypes.SearchResponse<any>;

export type GetSelectionsAndSizeResponse = {
    [key: string]: (number);
};

export type ClearData = {
    /**
     * Selection bucket name
     */
    bucket: string;
    /**
     * One or more record UUIDs
     */
    uuid?: Array<(string)>;
};

export type ClearResponse = number;

export type GetData = {
    /**
     * Bucket name
     */
    bucket: string;
};

export type GetResponse = Array<(string)>;

export type AddData = {
    /**
     * Bucket name
     */
    bucket: string;
    /**
     * One or more record UUIDs. If null, select all in current search if bucket name is 'metadata' (TODO: remove this limitation?).
     */
    uuid?: Array<(string)>;
};

export type AddResponse = number;

export type GetSiteOrPortalDescriptionResponse = SettingsListResponse;

export type IndexSiteData = {
    /**
     * Asynchronous mode (only on all records. ie. no selection bucket)
     */
    asynchronous?: boolean;
    /**
     * Selection bucket name
     */
    bucket?: string;
    /**
     * Index. By default only remove record index.
     */
    indices?: Array<(string)>;
    /**
     * Drop and recreate index
     */
    reset?: boolean;
};

export type IndexSiteResponse = string;

export type IndexCommitResponse = unknown;

export type CommitIndexChangesResponse = unknown;

export type IndexStatusResponse = Status;

export type IndexAndDbSynchronizationStatusResponse = {
    [key: string]: {
        [key: string]: unknown;
    };
};

export type IsIndexingResponse = boolean;

export type GetInformationResponse = SiteInformation;

export type GetSystemInfoResponse = SystemInfo;

export type IsCasEnabledResponse = boolean;

export type GetNotificationLevelResponse = Array<('statusUserOwner' | 'catalogueAdministrator' | 'catalogueProfileAdministrator' | 'catalogueProfileUserAdmin' | 'catalogueProfileReviewer' | 'catalogueProfileEditor' | 'catalogueProfileRegisteredUser' | 'catalogueProfileGuest' | 'recordProfileReviewer' | 'recordUserAuthor' | 'recordGroupEmail')>;

export type GetProxyConfigurationResponse = ProxyConfiguration;

export type IsReadOnlyResponse = boolean;

export type UpdateStagingProfileData = {
    profile: 'testing' | 'development' | 'production';
};

export type UpdateStagingProfileResponse = void;

export type GetXslTransformationsResponse = Array<(string)>;

export type GetLogFilesResponse = Array<LogFileResponse>;

export type GetLastActivityData = {
    /**
     * Number of lines to return
     */
    lines?: number;
};

export type GetLastActivityResponse = string;

export type GetLastActivityInAzipResponse = unknown;

export type SetLogoData = {
    /**
     * Create favicon too
     */
    asFavicon?: boolean;
    /**
     * Logo to use for the catalog
     */
    file: string;
};

export type SetLogoResponse = void;

export type GetSettingsSetData = {
    /**
     * Setting key
     */
    key?: Array<(string)>;
    /**
     * Setting set. A common set of settings to retrieve.
     */
    set?: Array<('INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE')>;
};

export type GetSettingsSetResponse = SettingsListResponse;

export type SaveSettingsData = {
    allRequestParams: {
        [key: string]: (string);
    };
};

export type SaveSettingsResponse = void;

export type GetSettingsDetailsData = {
    /**
     * Setting key
     */
    key?: Array<(string)>;
    /**
     * Setting set. A common set of settings to retrieve.
     */
    set?: Array<('INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE')>;
};

export type GetSettingsDetailsResponse = Array<Setting>;

export type GetSitemapData = {
    /**
     * page.
     */
    doc?: number;
    /**
     * Format (xml or html).
     */
    format?: string;
};

export type GetSitemapResponse = unknown;

export type GetSourcesData = {
    /**
     * Group owner of the source (only applies to subportal).
     */
    group?: number;
};

export type GetSourcesResponse = Array<Source>;

export type AddSourceData = {
    requestBody: Source;
};

export type AddSourceResponse = string;

export type DeleteSourceData = {
    /**
     * Source identifier
     */
    sourceIdentifier: string;
};

export type DeleteSourceResponse = string;

export type UpdateSourceData = {
    requestBody: Source;
    /**
     * Source identifier
     */
    sourceIdentifier: string;
};

export type UpdateSourceResponse = string;

export type GetSourcesByTypeData = {
    type: 'portal' | 'subportal' | 'externalportal' | 'harvester';
};

export type GetSourcesByTypeResponse = Array<Source>;

export type GetStandardConfigurationsResponse = unknown;

export type GetConfigurationsData = {
    /**
     * Schema identifiers
     */
    schema?: Array<(string)>;
};

export type GetConfigurationsResponse = {
    [key: string]: BatchEditing;
};

export type ReloadSchemaResponse = unknown;

export type GetConfigurationData = {
    /**
     * Schema identifier
     */
    schema: string;
};

export type GetConfigurationResponse = {
    [key: string]: BatchEditing;
};

export type GetCodelistsTranslationsData = {
    /**
     * Codelist element name or alias
     */
    codelist: Array<(string)>;
    /**
     * Schema identifier
     */
    schema: string;
};

export type GetCodelistsTranslationsResponse = {
    [key: string]: (string);
};

export type GetSchemaTranslationsData = {
    /**
     * Codelist element name or alias
     */
    codelist: string;
    displayIf?: string;
    isoType?: string;
    parent?: string;
    /**
     * Schema identifier
     */
    schema: string;
    xpath?: string;
};

export type GetSchemaTranslationsResponse = {
    [key: string]: (string);
};

export type GetSchemaCodelistsWithDetailsData = {
    /**
     * Codelist element name or alias
     */
    codelist: string;
    /**
     * Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     */
    displayIf?: string;
    /**
     * ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     */
    isoType?: string;
    /**
     * Parent name with namespace which may indicate a more precise label as defined in context attribute.
     */
    parent?: string;
    /**
     * Schema identifier
     */
    schema: string;
    /**
     * XPath of the element to target which may indicate a more precise label as defined in context attribute.
     */
    xpath?: string;
};

export type GetSchemaCodelistsWithDetailsResponse = Codelist;

export type GetElementDetailsData = {
    displayIf?: string;
    /**
     * Descriptor name
     */
    element: string;
    isoType?: string;
    parent?: string;
    /**
     * Schema identifier
     */
    schema: string;
    xpath?: string;
};

export type GetElementDetailsResponse = Element;

export type GetEditorAssociatedPanelConfigurationData = {
    /**
     * Configuration identifier
     */
    name: string;
    /**
     * Schema identifier
     */
    schema: string;
};

export type GetEditorAssociatedPanelConfigurationResponse = string;

export type DeleteAllHistoryAndStatusResponse = void;

export type GetStatusListResponse = Array<StatusValue>;

export type GetStatusByTypeData = {
    /**
     * Type
     */
    type: 'workflow' | 'task' | 'event';
};

export type GetStatusByTypeResponse = Array<StatusValue>;

export type GetTagsResponse = Array<MetadataCategory>;

export type PutTagData = {
    requestBody: MetadataCategory;
};

export type PutTagResponse = number;

export type DeleteTagData = {
    /**
     * Tag identifier
     */
    tagIdentifier: number;
};

export type DeleteTagResponse = string;

export type GetTagData = {
    /**
     * Tag identifier
     */
    tagIdentifier: number;
};

export type GetTagResponse = MetadataCategory;

export type UpdateTagData = {
    requestBody: MetadataCategory;
    /**
     * Tag identifier
     */
    tagIdentifier: number;
};

export type UpdateTagResponse = string;

export type TestMailConfigurationResponse = string;

export type CallStepData = {
    /**
     * Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     */
    stepName: string;
};

export type CallStepResponse = string;

export type BuildFilterData = {
    /**
     * The filters in JSON
     */
    filters: string;
};

export type BuildFilterResponse = string;

export type DeteleSldResponse = unknown;

export type GetSldResponse = Array<(string)>;

export type BuildSldData = {
    /**
     * The filters in JSON
     */
    filters: string;
    /**
     * The layers
     */
    layers: string;
    /**
     * The WMS server URL
     */
    url: string;
};

export type BuildSldResponse = string;

export type DownloadSldData = {
    extension: string;
    /**
     * The SLD identifier
     */
    id: number;
};

export type DownloadSldResponse = unknown;

export type GetTranslationProviderNamesResponse = Array<(string)>;

export type GetUiConfigurationsResponse = Array<UiSetting>;

export type PutUiConfigurationData = {
    requestBody: UiSetting;
};

export type PutUiConfigurationResponse = string;

export type DeleteUiConfigurationData = {
    /**
     * UI configuration identifier
     */
    uiIdentifier: string;
};

export type DeleteUiConfigurationResponse = string;

export type GetUiConfigurationData = {
    /**
     * UI identifier
     */
    uiIdentifier: string;
};

export type GetUiConfigurationResponse = UiSetting;

export type UpdateUiConfigurationData = {
    requestBody: UiSetting;
    /**
     * UI configuration identifier
     */
    uiIdentifier: string;
};

export type UpdateUiConfigurationResponse = string;

export type SendPasswordByEmailData = {
    /**
     * The user name
     */
    username: string;
};

export type SendPasswordByEmailResponse = string;

export type RegisterUserData = {
    requestBody: UserRegisterDto;
};

export type RegisterUserResponse = string;

export type UpdatePasswordData = {
    requestBody: PasswordUpdateParameter;
    /**
     * The user name
     */
    username: string;
};

export type UpdatePasswordResponse = string;

export type GetUserCommentsData = {
    /**
     * Metadata record UUID.
     */
    metadataUuid?: string;
    /**
     * Maximum number of feedback to return.
     */
    size?: number;
};

export type GetUserCommentsResponse = Array<UserFeedbackDTO>;

export type NewUserFeedbackData = {
    requestBody: UserFeedbackDTO;
};

export type NewUserFeedbackResponse = string;

export type GetRatingCriteriaResponse = Array<RatingCriteria>;

export type DeleteUserFeedbackData = {
    /**
     * User feedback UUID.
     */
    uuid: string;
};

export type DeleteUserFeedbackResponse = string;

export type GetUserCommentData = {
    /**
     * User feedback UUID.
     */
    uuid: string;
};

export type GetUserCommentResponse = UserFeedbackDTO;

export type PublishFeedbackData = {
    /**
     * User feedback UUID.
     */
    uuid: string;
};

export type PublishFeedbackResponse = string;

export type GetUsersResponse = Array<User>;

export type CreateUserData = {
    requestBody: UserDto;
};

export type CreateUserResponse = string;

export type RetrieveAllUserGroupsResponse = Array<UserGroupsResponse>;

export type GetRecordOwnersResponse = Array<OwnerResponse>;

export type SaveOwnersData = {
    requestBody: TransferRequest;
};

export type SaveOwnersResponse = string;

export type CheckUserPropertyExistData = {
    /**
     * The value to search
     */
    exist: string;
    /**
     * The user property to check
     */
    property: string;
};

export type CheckUserPropertyExistResponse = 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';

export type DeleteUserData = {
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type DeleteUserResponse = string;

export type GetUserData = {
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type GetUserResponse = User;

export type UpdateUserData = {
    requestBody: UserDto;
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type UpdateUserResponse = string;

export type GetUserIdenticonData = {
    /**
     * Size.
     */
    size?: number;
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type GetUserIdenticonResponse = unknown;

export type ResetUserPasswordData = {
    requestBody: PasswordResetDto;
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type ResetUserPasswordResponse = string;

export type RetrieveUserGroupsData = {
    /**
     * User identifier.
     */
    userIdentifier: number;
};

export type RetrieveUserGroupsResponse = Array<UserGroup>;

export type GetUserCustomSearchesResponse = Array<UserSearchDto>;

export type CreateUserCustomSearchData = {
    requestBody: UserSearchDto;
};

export type CreateUserCustomSearchResponse = number;

export type GetAllUserCustomSearchesData = {
    /**
     * Featured type search.
     */
    featuredType?: 'HOME' | 'EDITOR_BOARD';
};

export type GetAllUserCustomSearchesResponse = Array<UserSearchDto>;

export type GetAllUserCustomSearchesPageData = {
    /**
     * Featured  type search.
     */
    featuredType?: 'HOME' | 'EDITOR_BOARD';
    /**
     * Number of records to return
     */
    limit?: number;
    /**
     * From page
     */
    offset?: number;
    search?: string;
};

export type GetAllUserCustomSearchesPageResponse = PaginatedUserSearchResponse;

export type GetFeaturedUserCustomSearchesData = {
    /**
     * Number of records to return
     */
    type?: 'HOME' | 'EDITOR_BOARD';
};

export type GetFeaturedUserCustomSearchesResponse = Array<UserSearchDto>;

export type DeleteUserCustomSerachData = {
    /**
     * Search identifier.
     */
    searchIdentifier: number;
};

export type DeleteUserCustomSerachResponse = string;

export type GetUserCustomSearchData = {
    /**
     * User search identifier
     */
    searchIdentifier: number;
};

export type GetUserCustomSearchResponse = UserSearchDto;

export type UpdateCustomUserSearchData = {
    requestBody: UserSearchDto;
    /**
     * User search identifier
     */
    searchIdentifier: number;
};

export type UpdateCustomUserSearchResponse = void;

export type GetSelectionListResponse = Array<Selection>;

export type CreatePersistentSelectionTypeData = {
    requestBody: Selection;
};

export type CreatePersistentSelectionTypeResponse = string;

export type DeleteUserSelectionData = {
    /**
     * Selection identifier
     */
    selectionIdentifier: number;
};

export type DeleteUserSelectionResponse = string;

export type UpdateUserSelectionData = {
    requestBody: Selection;
    /**
     * Selection identifier
     */
    selectionIdentifier: number;
};

export type UpdateUserSelectionResponse = string;

export type DeleteFromUserSelectionData = {
    /**
     * Selection identifier
     */
    selectionIdentifier: number;
    /**
     * User identifier
     */
    userIdentifier: number;
    /**
     * One or more record UUIDs. If null, remove all.
     */
    uuid?: Array<(string)>;
};

export type DeleteFromUserSelectionResponse = string;

export type GetSelectionRecordsData = {
    /**
     * Selection identifier
     */
    selectionIdentifier: number;
    /**
     * User identifier
     */
    userIdentifier: number;
};

export type GetSelectionRecordsResponse = Array<(string)>;

export type AddToUserSelectionData = {
    /**
     * Selection identifier
     */
    selectionIdentifier: number;
    /**
     * User identifier
     */
    userIdentifier: number;
    /**
     * One or more record UUIDs.
     */
    uuid?: Array<(string)>;
};

export type AddToUserSelectionResponse = string;

export type $OpenApiTs = {
    '/atom/describe/resource': {
        get: {
            req: DescribeResourceData;
            res: {
                /**
                 * Feeds.
                 */
                200: unknown;
                /**
                 * Not authenticated.
                 */
                204: void;
            };
        };
    };
    '/atom/describe/service/{metadataUuid}': {
        get: {
            req: DescribeData;
            res: {
                /**
                 * Feeds.
                 */
                200: unknown;
                /**
                 * Not authenticated.
                 */
                204: void;
            };
        };
    };
    '/atom/download/resource': {
        get: {
            req: DownloadResourceData;
            res: {
                /**
                 * Get a data file related to dataset
                 */
                200: unknown;
                /**
                 * Not authenticated.
                 */
                204: void;
            };
        };
    };
    '/atom/feeds': {
        get: {
            req: FeedsData;
            res: {
                /**
                 * Get a list of feeds.
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/atom/scan': {
        get: {
            res: {
                /**
                 * Scan completed.
                 */
                201: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/customstyle': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
        post: {
            req: SaveCssStyleData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/formatters': {
        get: {
            req: ListFormattersData;
            res: {
                /**
                 * OK
                 */
                200: FormatterDataResponse;
            };
        };
        post: {
            req: AddFormatterData;
            res: {
                /**
                 * Created
                 */
                201: unknown;
            };
        };
    };
    '/formatters/cache': {
        delete: {
            res: {
                /**
                 * Cache cleared.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrator can access it.
                 */
                403: unknown;
            };
        };
    };
    '/formatters/{schema}/{formatter}': {
        delete: {
            req: DeleteFormatterData;
            res: {
                /**
                 * No Content
                 */
                204: void;
            };
        };
        get: {
            req: DownloadFormatterData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/formatters/{schema}/{formatter}/files': {
        get: {
            req: GetFormatterFilesData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/formatters/{schema}/{formatter}/files/{file}': {
        get: {
            req: GetFormatterFileContentData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
        post: {
            req: UpdateFormatterFileData;
            res: {
                /**
                 * Created
                 */
                201: unknown;
            };
        };
    };
    '/groups': {
        get: {
            req: GetGroupsData;
            res: {
                /**
                 * OK
                 */
                200: Array<Group>;
            };
        };
        put: {
            req: AddGroupData;
            res: {
                /**
                 * Group created.
                 */
                201: number;
                /**
                 * Group with that id or name already exist.
                 */
                400: number;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: number;
            };
        };
    };
    '/groups/{groupIdentifier}': {
        delete: {
            req: DeleteGroupData;
            res: {
                /**
                 * Group removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        get: {
            req: GetGroupData;
            res: {
                /**
                 * Group information for the group id supplied.
                 */
                200: Group;
                /**
                 * Resource not found.
                 */
                404: Group;
            };
        };
        put: {
            req: UpdateGroupData;
            res: {
                /**
                 * Group updated.
                 */
                204: void;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/groups/{groupIdentifier}/users': {
        get: {
            req: GetGroupUsersData;
            res: {
                /**
                 * List of users in that group.
                 */
                200: Array<User>;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: Array<User>;
                /**
                 * Resource not found.
                 */
                404: Array<User>;
            };
        };
    };
    '/groups/{groupId}/logo': {
        get: {
            req: GetGroupLogoData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/harvesters/properties/{property}': {
        get: {
            req: CheckHarvesterPropertyExistData;
            res: {
                /**
                 * Property does not exist.
                 */
                200: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * A property with that value already exist.
                 */
                404: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
            };
        };
    };
    '/harvesters/{harvesterUuid}/assign': {
        post: {
            req: AssignHarvestedRecordToSourceData;
            res: {
                /**
                 * Harvester records transfered to new source.
                 */
                204: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * Resource not found.
                 */
                404: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
            };
        };
    };
    '/i18n/cache': {
        delete: {
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/i18n/db': {
        get: {
            req: GetTranslationsData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/i18n/db/custom': {
        get: {
            req: GetCustomTranslationsData;
            res: {
                /**
                 * OK
                 */
                200: Array<Translations>;
            };
        };
    };
    '/i18n/db/translations': {
        delete: {
            res: {
                /**
                 * Created
                 */
                201: unknown;
            };
        };
        get: {
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
        put: {
            req: AddTranslationsData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/i18n/db/translations/{key}': {
        delete: {
            req: DeleteTranslationsData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
        put: {
            req: AddTranslationsForData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/i18n/packages': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: Array<(string)>;
                };
            };
        };
    };
    '/i18n/packages/{pack}': {
        get: {
            req: GetTranslationsPackageData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/identifiers': {
        get: {
            req: GetIdentifiersData;
            res: {
                /**
                 * List of identifier templates.
                 */
                200: Array<MetadataIdentifierTemplate>;
                /**
                 * Operation not allowed. Only Editor can access it.
                 */
                403: Array<MetadataIdentifierTemplate>;
            };
        };
        put: {
            req: AddIdentifierData;
            res: {
                /**
                 * Identifier template created.
                 */
                201: number;
                /**
                 * Operation not allowed. Only Editor can access it.
                 */
                403: number;
            };
        };
    };
    '/identifiers/{identifier}': {
        delete: {
            req: DeleteIdentifierData;
            res: {
                /**
                 * Template identifier removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Editor can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        put: {
            req: UpdateIdentifierData;
            res: {
                /**
                 * Identifier template updated.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Editor can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/isolanguages': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<IsoLanguage>;
            };
        };
    };
    '/languages': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<Language>;
            };
        };
    };
    '/languages/application': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<Language>;
            };
        };
    };
    '/languages/{langCode}': {
        delete: {
            req: DeleteLanguageData;
            res: {
                /**
                 * Language translations removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrator can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        put: {
            req: AddLanguagesData;
            res: {
                /**
                 * Language translations added.
                 */
                201: unknown;
                /**
                 * Operation not allowed. Only Administrator can access it.
                 */
                403: unknown;
                /**
                 * Resource not found. eg. No SQL file available for that langugae.
                 */
                404: unknown;
            };
        };
    };
    '/logos': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
        post: {
            req: AddLogoData;
            res: {
                /**
                 * Logo added.
                 */
                201: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
    };
    '/logos/{file}': {
        delete: {
            req: DeleteLogoData;
            res: {
                /**
                 * Logo removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        get: {
            req: GetLogoData;
            res: {
                /**
                 * Logo returned.
                 */
                200: unknown;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/mapservers': {
        get: {
            res: {
                /**
                 * List of all mapservers.
                 */
                200: Array<AnonymousMapserver>;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: Array<AnonymousMapserver>;
            };
        };
        put: {
            req: AddMapserverData;
            res: {
                /**
                 * Mapserver created.
                 */
                201: number;
                /**
                 * Bad parameters.
                 */
                400: number;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: number;
            };
        };
    };
    '/mapservers/{mapserverId}': {
        delete: {
            req: DeleteMapserverData;
            res: {
                /**
                 * Mapserver removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        get: {
            req: GetMapserverData;
            res: {
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: AnonymousMapserver;
                /**
                 * Resource not found.
                 */
                404: AnonymousMapserver;
            };
        };
        put: {
            req: UpdateMapserverData;
            res: {
                /**
                 * Mapserver updated.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/mapservers/{mapserverId}/auth': {
        post: {
            req: UpdateMapserverAuthData;
            res: {
                /**
                 * Mapserver updated.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/mapservers/{mapserverId}/records/{metadataUuid}': {
        delete: {
            req: DeleteMapserverResourceData;
            res: {
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: string;
            };
        };
        get: {
            req: GetMapserverResourceData;
            res: {
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: string;
            };
        };
        put: {
            req: PublishMapserverResourceData;
            res: {
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: string;
            };
        };
    };
    '/mapservices': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<MapService>;
            };
        };
    };
    '/me': {
        get: {
            res: {
                /**
                 * Authenticated. Return user details.
                 */
                200: MeResponse;
            };
        };
    };
    '/operations': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<Operation>;
            };
        };
    };
    '/pages': {
        get: {
            req: ListPagesData;
            res: {
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: Array<PageProperties>;
            };
        };
        post: {
            req: AddPageUploadingFileData;
            res: {
                /**
                 * Page saved
                 */
                201: string;
                /**
                 * Wrong parameters are provided
                 */
                400: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
                /**
                 * Page already in the system: use PUT
                 */
                409: string;
                /**
                 * File not valid
                 */
                500: string;
            };
        };
        put: {
            req: AddPageWithoutUploadingFileData;
            res: {
                /**
                 * Page saved
                 */
                201: string;
                /**
                 * Wrong parameters are provided
                 */
                400: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
                /**
                 * Page already in the system: use PUT
                 */
                409: string;
                /**
                 * File not valid
                 */
                500: string;
            };
        };
    };
    '/pages/config/formats': {
        get: {
            res: {
                /**
                 * Page found
                 */
                200: Array<('LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT')>;
            };
        };
    };
    '/pages/config/sections': {
        get: {
            res: {
                /**
                 * Page found
                 */
                200: Array<('TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3')>;
            };
        };
    };
    '/pages/config/status': {
        get: {
            res: {
                /**
                 * Page found
                 */
                200: Array<('PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN')>;
            };
        };
    };
    '/pages/{language}/{pageId}': {
        delete: {
            req: DeletePageData;
            res: {
                /**
                 * Page removed
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
                /**
                 * Page not found
                 */
                404: unknown;
            };
        };
        get: {
            req: GetPageData;
            res: {
                /**
                 * Page found
                 */
                200: PageProperties;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: PageProperties;
                /**
                 * Page not found
                 */
                404: PageProperties;
            };
        };
        put: {
            req: UpdatePageData;
            res: {
                /**
                 * Page changes saved
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/pages/{language}/{pageId}/content': {
        get: {
            req: GetPageContentData;
            res: {
                /**
                 * Page found
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: string;
                /**
                 * Page not found
                 */
                404: string;
            };
        };
    };
    '/processes/db/search-and-replace': {
        get: {
            req: PreviewProcessSearchAndReplaceData;
            res: {
                /**
                 * Processed records.
                 */
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: {
                    [key: string]: unknown;
                };
                /**
                 * If one record processed is invalid.
                 */
                500: {
                    [key: string]: unknown;
                };
            };
        };
        post: {
            req: ProcessSearchAndReplaceData;
            res: {
                /**
                 * Report about processed records.
                 */
                201: XsltMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: XsltMetadataProcessingReport;
            };
        };
    };
    '/processes/reports': {
        delete: {
            res: {
                /**
                 * Report registry cleared.
                 */
                204: void;
                /**
                 * Operation not allowed. Only authenticated user can access it.
                 */
                403: unknown;
            };
        };
        get: {
            res: {
                /**
                 * List of reports returned.
                 */
                200: Array<ProcessingReport>;
                /**
                 * Operation not allowed. Only authenticated user can access it.
                 */
                403: Array<ProcessingReport>;
            };
        };
    };
    '/processes/search-and-replace': {
        post: {
            req: SearchAndReplaceData;
            res: {
                /**
                 * Replacements applied.
                 */
                200: MetadataReplacementProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataReplacementProcessingReport;
            };
        };
    };
    '/processes/{process}': {
        get: {
            req: PreviewProcessRecordsData;
            res: {
                /**
                 * Processed records.
                 */
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: {
                    [key: string]: unknown;
                };
            };
        };
        post: {
            req: ProcessRecordsData;
            res: {
                /**
                 * Report about processed records.
                 */
                201: XsltMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: XsltMetadataProcessingReport;
            };
        };
    };
    '/records': {
        delete: {
            req: DeleteRecordsData;
            res: {
                /**
                 * Report about deleted records.
                 */
                200: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
        get: {
            req: GetAsRdfData;
            res: {
                /**
                 * Return the catalog content as RDF.
                 */
                200: unknown;
                /**
                 * Redirect the client to the first in-sequence page resource. This happens when the paging parameters (from, hitsPerPage) are not included in the request.
                 */
                303: unknown;
            };
        };
        post: {
            req: InsertFileData;
            res: {
                /**
                 * Report about imported records.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
        put: {
            req: InsertData;
            res: {
                /**
                 * Report about imported records.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/approve': {
        put: {
            req: ApproveData;
            res: {
                /**
                 * Metadata approved .
                 */
                200: MetadataProcessingReport;
                /**
                 * Metadata workflow not enabled.
                 */
                400: MetadataProcessingReport;
            };
        };
    };
    '/records/backups': {
        put: {
            res: {
                /**
                 * Return succeed message.
                 */
                200: string;
            };
        };
    };
    '/records/backups/latest': {
        get: {
            res: {
                /**
                 * Resource not found.
                 */
                404: (Blob | File);
            };
        };
    };
    '/records/batchediting': {
        put: {
            req: BatchEditData;
            res: {
                /**
                 * Return a report of what has been done.
                 */
                201: IProcessingReport;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: IProcessingReport;
            };
        };
    };
    '/records/batchediting/preview': {
        post: {
            req: PreviewBatchEditData;
            res: {
                /**
                 * Processed records.
                 */
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/records/csv': {
        get: {
            req: ExportAsCsvData;
            res: {
                /**
                 * Return requested records as CSV.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/duplicate': {
        put: {
            req: CreateData;
            res: {
                /**
                 * Return the internal id of the newly created record.
                 */
                201: string;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: string;
            };
        };
    };
    '/records/importfrommap': {
        post: {
            req: InsertOgcMapContextFileData;
            res: {
                /**
                 * Report about imported records.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/index': {
        get: {
            req: IndexData;
            res: {
                /**
                 * Record indexed.
                 */
                200: IndexResponse;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: IndexResponse;
            };
        };
    };
    '/records/links': {
        delete: {
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
        get: {
            req: GetRecordLinksData;
            res: {
                /**
                 * OK
                 */
                200: PageLink;
            };
        };
        post: {
            req: GetRecordLinksPostData;
            res: {
                /**
                 * OK
                 */
                200: PageLink;
            };
        };
    };
    '/records/links/analyze': {
        post: {
            req: AnalyzeRecordLinksData;
            res: {
                /**
                 * Created
                 */
                201: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/links/analyzeurl': {
        post: {
            req: AnalyzeLinksData;
            res: {
                /**
                 * Created
                 */
                201: unknown;
            };
        };
    };
    '/records/links/csv': {
        get: {
            req: GetRecordLinksAsCsvData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/records/ownership': {
        put: {
            req: SetGroupAndOwnerData;
            res: {
                /**
                 * Records group and owner updated
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/pdf': {
        get: {
            req: ExportAsPdfData;
            res: {
                /**
                 * Return requested records as PDF.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/publish': {
        put: {
            req: PublishMultipleRecordsData;
            res: {
                /**
                 * Report about updated privileges.
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/samples': {
        put: {
            req: AddSamplesData;
            res: {
                /**
                 * Return a report of what has been done.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/sharing': {
        get: {
            res: {
                /**
                 * Return a default array of group and operations that can be used to set record sharing properties.
                 */
                200: SharingResponse;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: SharingResponse;
            };
        };
        put: {
            req: ShareMultipleRecordsData;
            res: {
                /**
                 * Report about updated privileges.
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/sharing/options': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<PublicationOption>;
            };
        };
    };
    '/records/status/search': {
        get: {
            req: GetWorkflowStatusByTypeData;
            res: {
                /**
                 * OK
                 */
                200: Array<MetadataStatusResponse>;
            };
        };
    };
    '/records/submit': {
        put: {
            req: SubmitData;
            res: {
                /**
                 * Metadata submitted .
                 */
                200: MetadataProcessingReport;
                /**
                 * Metadata workflow not enabled.
                 */
                400: MetadataProcessingReport;
            };
        };
    };
    '/records/tags': {
        delete: {
            req: DeleteTagForRecordsData;
            res: {
                /**
                 * Report about removed records.
                 */
                200: MetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataProcessingReport;
            };
        };
        put: {
            req: TagRecordsData;
            res: {
                /**
                 * Report about updated records.
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/templates': {
        put: {
            req: AddTemplatesData;
            res: {
                /**
                 * Return a report of what has been done.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/unpublish': {
        put: {
            req: UnpublishMultipleRecordsData;
            res: {
                /**
                 * Report about updated privileges.
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/validate': {
        delete: {
            req: CleanValidationStatusData;
            res: {
                /**
                 * Records validation status cleared.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
        put: {
            req: ValidateRecordsData;
            res: {
                /**
                 * Records validated.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/records/validate/inspire': {
        put: {
            req: ValidateRecordsInspireData;
            res: {
                /**
                 * Records validated.
                 */
                201: string;
                /**
                 * Operation not allowed. Only Editors can access it.
                 */
                403: string;
            };
        };
    };
    '/records/versions': {
        put: {
            req: EnableVersionControlForRecordsData;
            res: {
                /**
                 * OK
                 */
                200: MetadataProcessingReport;
            };
        };
    };
    '/records/zip': {
        get: {
            req: ExportAsMefData;
            res: {
                /**
                 * Return requested records as ZIP.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}': {
        delete: {
            req: DeleteRecordData;
            res: {
                /**
                 * Record deleted.
                 */
                204: void;
                /**
                 * This template is referenced
                 */
                401: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        get: {
            req: GetRecordData;
            res: {
                /**
                 * Return the record.
                 */
                200: (Blob | File);
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: string;
                /**
                 * Resource not found.
                 */
                404: string;
            };
        };
    };
    '/records/{metadataUuid}/alert': {
        post: {
            req: SendEmailToContactData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/records/{metadataUuid}/associated': {
        get: {
            req: GetAssociatedResourcesData;
            res: {
                /**
                 * Return the associated resources.
                 */
                200: {
                    [key: string]: Array<AssociatedRecord>;
                };
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: {
                    [key: string]: Array<AssociatedRecord>;
                };
            };
        };
    };
    '/records/{metadataUuid}/attachments': {
        delete: {
            req: DelResourcesData;
            res: {
                /**
                 * Attachment added.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        get: {
            req: GetAllResourcesData;
            res: {
                /**
                 * Return the record attachments.
                 */
                200: Array<MetadataResource>;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: Array<MetadataResource>;
            };
        };
        post: {
            req: PutResourceData;
            res: {
                /**
                 * Attachment uploaded.
                 */
                201: MetadataResource;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataResource;
            };
        };
        put: {
            req: PutResourceFromUrlData;
            res: {
                /**
                 * Attachment added.
                 */
                201: MetadataResource;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataResource;
            };
        };
    };
    '/records/{metadataUuid}/attachments/print-thumbnail': {
        put: {
            req: SaveThumbnailData;
            res: {
                /**
                 * Thumbnail created.
                 */
                201: MetadataResource;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataResource;
            };
        };
    };
    '/records/{metadataUuid}/attachments/{resourceId}': {
        delete: {
            req: DelResourceData;
            res: {
                /**
                 * Attachment visibility removed.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        get: {
            req: GetResourceData;
            res: {
                /**
                 * Record attachment.
                 */
                200: (Blob | File);
                /**
                 * Operation not allowed. User needs to be able to download the resource.
                 */
                403: unknown;
            };
        };
        patch: {
            req: PatchResourceData;
            res: {
                /**
                 * Attachment visibility updated.
                 */
                201: MetadataResource;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataResource;
            };
        };
    };
    '/records/{metadataUuid}/doi': {
        delete: {
            req: UnregisterDoiData;
            res: {
                /**
                 * DOI unregistered.
                 */
                204: string;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: string;
                /**
                 * Metadata or DOI not found.
                 */
                404: string;
                /**
                 * Service unavailable.
                 */
                500: string;
            };
        };
        put: {
            req: CreateDoiData;
            res: {
                /**
                 * Check status of the report.
                 */
                201: {
                    [key: string]: (string);
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: (string);
                };
                /**
                 * Metadata not found.
                 */
                404: {
                    [key: string]: (string);
                };
                /**
                 * Service unavailable.
                 */
                500: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/records/{metadataUuid}/doi/checkDoiUrl': {
        get: {
            req: CheckDoiUrlData;
            res: {
                /**
                 * DOI URL created.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
                /**
                 * Metadata not found.
                 */
                404: string;
                /**
                 * Service unavailable.
                 */
                500: string;
            };
        };
    };
    '/records/{metadataUuid}/doi/checkPreConditions': {
        get: {
            req: CheckDoiStatusData;
            res: {
                /**
                 * Record can be proposed to DataCite.
                 */
                200: {
                    [key: string]: (boolean);
                };
                /**
                 * Record does not meet preconditions. Check error message.
                 */
                400: {
                    [key: string]: (boolean);
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: (boolean);
                };
                /**
                 * Metadata not found.
                 */
                404: {
                    [key: string]: (boolean);
                };
                /**
                 * Service unavailable.
                 */
                500: {
                    [key: string]: (boolean);
                };
            };
        };
    };
    '/records/{metadataUuid}/editor': {
        delete: {
            req: CancelEditsData;
            res: {
                /**
                 * Editing session cancelled.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        get: {
            req: StartEditingData;
            res: {
                /**
                 * The editor form.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        post: {
            req: SaveEditsData;
            res: {
                /**
                 * The editor form.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/editor/attributes': {
        delete: {
            req: DeleteAttributeData;
            res: {
                /**
                 * Attribute removed.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/editor/elements': {
        delete: {
            req: DeleteElementData;
            res: {
                /**
                 * Element removed.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        put: {
            req: AddElementData;
            res: {
                /**
                 * Element added.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/editor/elements/{direction}': {
        put: {
            req: ReorderElementData;
            res: {
                /**
                 * Element reordered.
                 */
                201: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/extents.json': {
        get: {
            req: GetAllRecordExtentAsJsonData;
            res: {
                /**
                 * OK
                 */
                200: Array<ExtentDto>;
            };
        };
    };
    '/records/{metadataUuid}/extents.png': {
        get: {
            req: GetAllRecordExtentAsImageData;
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
    };
    '/records/{metadataUuid}/extents/{geometryIndex}.png': {
        get: {
            req: GetOneRecordExtentAsImageData;
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
    };
    '/records/{metadataUuid}/featureCatalog': {
        get: {
            req: GetFeatureCatalogData;
            res: {
                /**
                 * Return the associated resources.
                 */
                200: FeatureResponse;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: FeatureResponse;
            };
        };
    };
    '/records/{metadataUuid}/formatters/json': {
        get: {
            req: GetRecordAsJsonData;
            res: {
                /**
                 * Return the record.
                 */
                200: (Blob | File);
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/records/{metadataUuid}/formatters/xml': {
        get: {
            req: GetRecordAsXmlData;
            res: {
                /**
                 * Return the record.
                 */
                200: (Blob | File);
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/records/{metadataUuid}/formatters/zip': {
        get: {
            req: GetRecordAsZipData;
            res: {
                /**
                 * Return the record.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/formatters/{formatterId}': {
        get: {
            req: GetRecordFormattedByData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/records/{metadataUuid}/group': {
        put: {
            req: SetRecordGroupData;
            res: {
                /**
                 * Record group updated.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/ownership': {
        put: {
            req: SetRecordOwnershipData;
            res: {
                /**
                 * Record group and owner updated
                 */
                201: MetadataProcessingReport;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataProcessingReport;
            };
        };
    };
    '/records/{metadataUuid}/permalink': {
        get: {
            req: GetRecordPermalinkData;
            res: {
                /**
                 * Return the permalink URL.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: string;
                /**
                 * Resource not found.
                 */
                404: string;
            };
        };
    };
    '/records/{metadataUuid}/popularity': {
        get: {
            req: GetRecordPopularityData;
            res: {
                /**
                 * Popularity.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: string;
                /**
                 * Resource not found.
                 */
                404: string;
            };
        };
        post: {
            req: IncreaseRecordPopularityData;
            res: {
                /**
                 * Popularity updated.
                 */
                201: string;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: string;
                /**
                 * Resource not found.
                 */
                404: string;
            };
        };
    };
    '/records/{metadataUuid}/processes': {
        get: {
            req: GetSuggestionsData;
            res: {
                /**
                 * Record suggestions.
                 */
                200: Array<SuggestionType>;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: Array<SuggestionType>;
            };
        };
    };
    '/records/{metadataUuid}/processes/{process}': {
        get: {
            req: ProcessRecordPreviewData;
            res: {
                /**
                 * A preview of the processed record.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        post: {
            req: ProcessRecordData;
            res: {
                /**
                 * Record processed and saved.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
            };
        };
    };
    '/records/{metadataUuid}/publish': {
        put: {
            req: PublishData;
            res: {
                /**
                 * Settings updated.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/query': {
        get: {
            req: GetSavedQueriesData;
            res: {
                /**
                 * Saved query available.
                 */
                200: Array<SavedQuery>;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: Array<SavedQuery>;
            };
        };
    };
    '/records/{metadataUuid}/query/{savedQuery}': {
        post: {
            req: ApplyQueryData;
            res: {
                /**
                 * List of matching elements. If element are nodes, then they are returned as string.
                 */
                200: {
                    [key: string]: (string);
                };
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/records/{metadataUuid}/rate': {
        put: {
            req: RateRecordData;
            res: {
                /**
                 * New rating value.
                 */
                201: number;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: number;
            };
        };
    };
    '/records/{metadataUuid}/related': {
        get: {
            req: GetRelatedResourcesData;
            res: {
                /**
                 * Return the associated resources.
                 */
                200: RelatedResponse;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: RelatedResponse;
            };
        };
    };
    '/records/{metadataUuid}/sharing': {
        get: {
            req: GetRecordSharingSettingsData;
            res: {
                /**
                 * The record sharing settings.
                 */
                200: SharingResponse;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: SharingResponse;
            };
        };
        put: {
            req: ShareData;
            res: {
                /**
                 * Settings updated.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/status': {
        delete: {
            req: DeleteAllRecordStatusData;
            res: {
                /**
                 * Status removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
                /**
                 * Status not found.
                 */
                404: unknown;
            };
        };
        get: {
            req: GetRecordStatusHistoryData;
            res: {
                /**
                 * OK
                 */
                200: Array<MetadataStatusResponse>;
            };
        };
        put: {
            req: SetStatusData;
            res: {
                /**
                 * Status updated.
                 */
                201: {
                    [key: string]: ('UPDATED' | 'UNCHANGED' | 'DELETED');
                };
                /**
                 * Metadata workflow not enabled.
                 */
                400: {
                    [key: string]: ('UPDATED' | 'UNCHANGED' | 'DELETED');
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: ('UPDATED' | 'UNCHANGED' | 'DELETED');
                };
            };
        };
    };
    '/records/{metadataUuid}/status/workflow/last': {
        get: {
            req: GetStatusData;
            res: {
                /**
                 * Record status.
                 */
                200: MetadataWorkflowStatusResponse;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: MetadataWorkflowStatusResponse;
            };
        };
    };
    '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}': {
        delete: {
            req: DeleteRecordStatusData;
            res: {
                /**
                 * Status removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
                /**
                 * Status not found.
                 */
                404: unknown;
            };
        };
    };
    '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after': {
        get: {
            req: ShowStatusAfterData;
            res: {
                /**
                 * Version of the record after changes.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
            };
        };
    };
    '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before': {
        get: {
            req: ShowStatusBeforeData;
            res: {
                /**
                 * Previous version of the record.
                 */
                200: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
            };
        };
    };
    '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close': {
        put: {
            req: CloseTaskData;
            res: {
                /**
                 * Task closed.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
                /**
                 * Status not found.
                 */
                404: unknown;
            };
        };
    };
    '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore': {
        post: {
            req: RestoreAtStatusSaveData;
            res: {
                /**
                 * Record restored.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/status/{type}': {
        get: {
            req: GetRecordStatusHistoryByTypeData;
            res: {
                /**
                 * OK
                 */
                200: Array<MetadataStatusResponse>;
            };
        };
    };
    '/records/{metadataUuid}/tags': {
        delete: {
            req: DeleteTagsData;
            res: {
                /**
                 * Record tags removed.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
        get: {
            req: GetRecordTagsData;
            res: {
                /**
                 * Record tags.
                 */
                200: Array<MetadataCategory>;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: Array<MetadataCategory>;
            };
        };
        put: {
            req: TagRecordData;
            res: {
                /**
                 * Record tags added.
                 */
                201: unknown;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/unpublish': {
        put: {
            req: UnpublishData;
            res: {
                /**
                 * Settings updated.
                 */
                204: void;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: unknown;
            };
        };
    };
    '/records/{metadataUuid}/userfeedback': {
        get: {
            req: GetUserCommentsOnArecordData;
            res: {
                /**
                 * OK
                 */
                200: Array<UserFeedbackDTO>;
            };
        };
    };
    '/records/{metadataUuid}/userfeedbackrating': {
        get: {
            req: GetMetadataRatingData;
            res: {
                /**
                 * OK
                 */
                200: RatingAverage;
            };
        };
    };
    '/records/{metadataUuid}/validate/inspire': {
        put: {
            req: ValidateRecordForInspireData;
            res: {
                /**
                 * Check status of the report.
                 */
                201: string;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: string;
                /**
                 * Metadata not found.
                 */
                404: string;
                /**
                 * Service unavailable.
                 */
                500: string;
            };
        };
    };
    '/records/{metadataUuid}/validate/inspire/testsuites': {
        get: {
            req: GetTestSuitesData;
            res: {
                /**
                 * List of testsuites available.
                 */
                200: {
                    [key: string]: Array<(string)>;
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: Array<(string)>;
                };
            };
        };
    };
    '/records/{metadataUuid}/validate/internal': {
        put: {
            req: ValidateRecordData;
            res: {
                /**
                 * Validation report.
                 */
                201: Reports;
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: Reports;
            };
        };
    };
    '/records/{metadataUuid}/versions': {
        put: {
            req: EnableVersionControlData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/records/{testId}/validate/inspire': {
        get: {
            req: CheckValidationData;
            res: {
                /**
                 * Report ready.
                 */
                200: {
                    [key: string]: (string);
                };
                /**
                 * Operation not allowed. User needs to be able to edit the resource.
                 */
                403: {
                    [key: string]: (string);
                };
                /**
                 * Report id not found.
                 */
                404: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/regions': {
        get: {
            req: GetRegionsData;
            res: {
                /**
                 * List of regions.
                 */
                200: ListRegionsResponse;
            };
        };
    };
    '/regions/geom.png': {
        get: {
            req: GetGeomAsImageData;
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
    };
    '/regions/types': {
        get: {
            res: {
                /**
                 * List of region types.
                 */
                200: Array<Category>;
            };
        };
    };
    '/registries/actions/entries/collect': {
        get: {
            req: PreviewExtractedEntriesData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
        put: {
            req: ExtractEntriesData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/registries/actions/entries/import/spatial': {
        post: {
            req: ImportSpatialEntriesData;
            res: {
                /**
                 * Directory entries imported.
                 */
                201: SimpleMetadataProcessingReport;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: SimpleMetadataProcessingReport;
            };
        };
    };
    '/registries/actions/entries/synchronize': {
        get: {
            req: PreviewUpdatedRecordEntriesData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
        put: {
            req: UpdateRecordEntriesData;
            res: {
                /**
                 * Created
                 */
                201: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/registries/crs': {
        get: {
            req: SearchCrsData;
            res: {
                /**
                 * List of CRS.
                 */
                200: Array<Crs>;
            };
        };
    };
    '/registries/crs/types': {
        get: {
            res: {
                /**
                 * List of CRS types.
                 */
                200: Array<('CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS')>;
            };
        };
    };
    '/registries/crs/{id}': {
        get: {
            req: GetCrsData;
            res: {
                /**
                 * CRS details.
                 */
                200: Crs;
                /**
                 * CRS not found.
                 */
                404: Crs;
            };
        };
    };
    '/registries/entries/{uuid}': {
        get: {
            req: GetEntryData;
            res: {
                /**
                 * Directory entry.
                 */
                200: unknown;
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: unknown;
            };
        };
    };
    '/registries/vocabularies': {
        post: {
            req: UploadThesaurusData;
            res: {
                /**
                 * Thesaurus uploaded in SKOS format.
                 */
                201: string;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: string;
            };
        };
        put: {
            req: UploadThesaurusFromUrlData;
            res: {
                /**
                 * Thesaurus uploaded in SKOS format.
                 */
                201: string;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: string;
            };
        };
    };
    '/registries/vocabularies/import/csv': {
        post: {
            req: ImportCsvAsThesaurusData;
            res: {
                /**
                 * Thesaurus converted and returned in response in SKOS format.
                 */
                200: unknown;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: unknown;
            };
        };
    };
    '/registries/vocabularies/keyword': {
        get: {
            req: GetKeywordByIdData;
            res: {
                /**
                 * XML snippet with requested keywords.
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
        post: {
            req: GetKeywordByIdsData;
            res: {
                /**
                 * XML snippet with requested keywords.
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/registries/vocabularies/search': {
        get: {
            req: SearchKeywordsData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    '/registries/vocabularies/{thesaurus}': {
        delete: {
            req: DeleteThesaurusData;
            res: {
                /**
                 * Thesaurus deleted.
                 */
                200: unknown;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        get: {
            req: GetThesaurusData;
            res: {
                /**
                 * Thesaurus in SKOS format.
                 */
                200: (Blob | File);
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
        put: {
            req: UpdateThesaurusData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
            };
        };
    };
    '/related': {
        get: {
            req: GetAssociatedResourcesForRecordsData;
            res: {
                /**
                 * Return the associated resources.
                 */
                200: {
                    [key: string]: RelatedResponse;
                };
                /**
                 * Operation not allowed. User needs to be able to view the resource.
                 */
                403: {
                    [key: string]: RelatedResponse;
                };
            };
        };
    };
    '/reports/datadownloads': {
        get: {
            req: GetReportDataDownloadsData;
            res: {
                /**
                 * List of metadata file downloads.
                 */
                200: unknown;
            };
        };
    };
    '/reports/datauploads': {
        get: {
            req: GetReportDataUploadsData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/reports/metadatainternal': {
        get: {
            req: GetReportInternalMetadataData;
            res: {
                /**
                 * Metadata not published during a period.
                 */
                200: unknown;
            };
        };
    };
    '/reports/metadataupdated': {
        get: {
            req: GetReportUpdatedMetadataData;
            res: {
                /**
                 * Updated metadata during a period.
                 */
                200: unknown;
            };
        };
    };
    '/reports/users': {
        get: {
            req: GetActiveUsersData;
            res: {
                /**
                 * List of users "active" during a time period.
                 */
                200: unknown;
            };
        };
    };
    '/robots.txt': {
        get: {
            res: {
                /**
                 * robots.txt file for SEO.
                 */
                200: unknown;
            };
        };
    };
    '/search/records/_msearch': {
        post: {
            req: MsearchData;
            res: {
                /**
                 * Search results.
                 */
                200: string;
            };
        };
    };
    '/search/records/_search': {
        post: {
            req: SearchData;
            res: {
                /**
                 * Search results.
                 */
                200: string;
            };
        };
    };
    '/selections': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (number);
                };
            };
        };
    };
    '/selections/{bucket}': {
        delete: {
            req: ClearData;
            res: {
                /**
                 * OK
                 */
                200: number;
            };
        };
        get: {
            req: GetData;
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
        put: {
            req: AddData;
            res: {
                /**
                 * OK
                 */
                200: number;
            };
        };
    };
    '/site': {
        get: {
            res: {
                /**
                 * Site description.
                 */
                200: SettingsListResponse;
            };
        };
    };
    '/site/index': {
        put: {
            req: IndexSiteData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/site/index/commit': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
        put: {
            res: {
                /**
                 * Changes committed.
                 */
                201: unknown;
            };
        };
    };
    '/site/index/status': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Status;
            };
        };
    };
    '/site/index/synchronized': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    '/site/indexing': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: boolean;
            };
        };
    };
    '/site/info': {
        get: {
            res: {
                /**
                 * Site information.
                 */
                200: SiteInformation;
            };
        };
    };
    '/site/info/build': {
        get: {
            res: {
                /**
                 * Build info.
                 */
                200: SystemInfo;
            };
        };
    };
    '/site/info/isCasEnabled': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: boolean;
            };
        };
    };
    '/site/info/notificationLevels': {
        get: {
            res: {
                /**
                 * List of notification levels.
                 */
                200: Array<('statusUserOwner' | 'catalogueAdministrator' | 'catalogueProfileAdministrator' | 'catalogueProfileUserAdmin' | 'catalogueProfileReviewer' | 'catalogueProfileEditor' | 'catalogueProfileRegisteredUser' | 'catalogueProfileGuest' | 'recordProfileReviewer' | 'recordUserAuthor' | 'recordGroupEmail')>;
            };
        };
    };
    '/site/info/proxy': {
        get: {
            res: {
                /**
                 * Proxy configuration.
                 */
                200: ProxyConfiguration;
            };
        };
    };
    '/site/info/readonly': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: boolean;
            };
        };
    };
    '/site/info/staging/{profile}': {
        put: {
            req: UpdateStagingProfileData;
            res: {
                /**
                 * Staging profile saved.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
            };
        };
    };
    '/site/info/transforms': {
        get: {
            res: {
                /**
                 * XSLT available.
                 */
                200: Array<(string)>;
            };
        };
    };
    '/site/logging': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<LogFileResponse>;
            };
        };
    };
    '/site/logging/activity': {
        get: {
            req: GetLastActivityData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/site/logging/activity/zip': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/site/logo': {
        put: {
            req: SetLogoData;
            res: {
                /**
                 * Logo set.
                 */
                204: void;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: unknown;
            };
        };
    };
    '/site/settings': {
        get: {
            req: GetSettingsSetData;
            res: {
                /**
                 * Settings.
                 */
                200: SettingsListResponse;
            };
        };
        post: {
            req: SaveSettingsData;
            res: {
                /**
                 * Settings saved.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
            };
        };
    };
    '/site/settings/details': {
        get: {
            req: GetSettingsDetailsData;
            res: {
                /**
                 * Settings with details.
                 */
                200: Array<Setting>;
            };
        };
    };
    '/sitemap': {
        get: {
            req: GetSitemapData;
            res: {
                /**
                 * Site map.
                 */
                200: unknown;
            };
        };
    };
    '/sources': {
        get: {
            req: GetSourcesData;
            res: {
                /**
                 * List of source catalogues.
                 */
                200: Array<Source>;
            };
        };
        put: {
            req: AddSourceData;
            res: {
                /**
                 * Source created.
                 */
                201: string;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: string;
            };
        };
    };
    '/sources/{sourceIdentifier}': {
        delete: {
            req: DeleteSourceData;
            res: {
                /**
                 * Source deleted.
                 */
                204: string;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: string;
            };
        };
        put: {
            req: UpdateSourceData;
            res: {
                /**
                 * Source updated.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * Source not found.
                 */
                404: string;
            };
        };
    };
    '/sources/{type}': {
        get: {
            req: GetSourcesByTypeData;
            res: {
                /**
                 * OK
                 */
                200: Array<Source>;
            };
        };
    };
    '/standards': {
        get: {
            res: {
                /**
                 * List of standards.
                 */
                200: unknown;
            };
        };
    };
    '/standards/batchconfiguration': {
        get: {
            req: GetConfigurationsData;
            res: {
                /**
                 * Batch editor configuration.
                 */
                200: {
                    [key: string]: BatchEditing;
                };
            };
        };
    };
    '/standards/reload': {
        get: {
            res: {
                /**
                 * Standards reloaded.
                 */
                200: unknown;
            };
        };
    };
    '/standards/{schema}/batchconfiguration': {
        get: {
            req: GetConfigurationData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: BatchEditing;
                };
            };
        };
    };
    '/standards/{schema}/codelists': {
        get: {
            req: GetCodelistsTranslationsData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/standards/{schema}/codelists/{codelist}': {
        get: {
            req: GetSchemaTranslationsData;
            res: {
                /**
                 * OK
                 */
                200: {
                    [key: string]: (string);
                };
            };
        };
    };
    '/standards/{schema}/codelists/{codelist}/details': {
        get: {
            req: GetSchemaCodelistsWithDetailsData;
            res: {
                /**
                 * OK
                 */
                200: Codelist;
            };
        };
    };
    '/standards/{schema}/descriptors/{element}/details': {
        get: {
            req: GetElementDetailsData;
            res: {
                /**
                 * OK
                 */
                200: Element;
            };
        };
    };
    '/standards/{schema}/editor/associatedpanel/config/{name}.json': {
        get: {
            req: GetEditorAssociatedPanelConfigurationData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/status': {
        delete: {
            res: {
                /**
                 * Status removed.
                 */
                204: void;
                /**
                 * Operation not allowed. Only Administrators can access it.
                 */
                403: unknown;
            };
        };
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<StatusValue>;
            };
        };
    };
    '/status/{type}': {
        get: {
            req: GetStatusByTypeData;
            res: {
                /**
                 * OK
                 */
                200: Array<StatusValue>;
            };
        };
    };
    '/tags': {
        get: {
            res: {
                /**
                 * List of tags.
                 */
                200: Array<MetadataCategory>;
            };
        };
        put: {
            req: PutTagData;
            res: {
                /**
                 * Tag created. Return the new tag identifier.
                 */
                201: number;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: number;
            };
        };
    };
    '/tags/{tagIdentifier}': {
        delete: {
            req: DeleteTagData;
            res: {
                /**
                 * Tag removed.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
        get: {
            req: GetTagData;
            res: {
                /**
                 * Tag details.
                 */
                200: MetadataCategory;
            };
        };
        put: {
            req: UpdateTagData;
            res: {
                /**
                 * Tag updated.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
    };
    '/tools/mail/test': {
        get: {
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/tools/migration/steps/{stepName}': {
        put: {
            req: CallStepData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/tools/ogc/filter': {
        post: {
            req: BuildFilterData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/tools/ogc/sld': {
        delete: {
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
        post: {
            req: BuildSldData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/tools/ogc/sld/{id}.{extension}': {
        get: {
            req: DownloadSldData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/translationproviders': {
        get: {
            res: {
                /**
                 * List of translation provider names.
                 */
                200: Array<(string)>;
            };
        };
    };
    '/ui': {
        get: {
            res: {
                /**
                 * List of configuration.
                 */
                200: Array<UiSetting>;
            };
        };
        put: {
            req: PutUiConfigurationData;
            res: {
                /**
                 * UI configuration created. Return the new UI configuration identifier.
                 */
                201: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
    };
    '/ui/{uiIdentifier}': {
        delete: {
            req: DeleteUiConfigurationData;
            res: {
                /**
                 * UI Configuration removed.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * UI Configuration not found.
                 */
                404: string;
            };
        };
        get: {
            req: GetUiConfigurationData;
            res: {
                /**
                 * UI configuration.
                 */
                200: UiSetting;
            };
        };
        put: {
            req: UpdateUiConfigurationData;
            res: {
                /**
                 * UI configuration updated.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
    };
    '/user/actions/forgot-password': {
        put: {
            req: SendPasswordByEmailData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/user/actions/register': {
        put: {
            req: RegisterUserData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/user/{username}': {
        patch: {
            req: UpdatePasswordData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/userfeedback': {
        get: {
            req: GetUserCommentsData;
            res: {
                /**
                 * OK
                 */
                200: Array<UserFeedbackDTO>;
            };
        };
        post: {
            req: NewUserFeedbackData;
            res: {
                /**
                 * Created
                 */
                201: string;
            };
        };
    };
    '/userfeedback/ratingcriteria': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<RatingCriteria>;
            };
        };
    };
    '/userfeedback/{uuid}': {
        delete: {
            req: DeleteUserFeedbackData;
            res: {
                /**
                 * User feedback removed.
                 */
                204: string;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: string;
            };
        };
        get: {
            req: GetUserCommentData;
            res: {
                /**
                 * OK
                 */
                200: UserFeedbackDTO;
            };
        };
    };
    '/userfeedback/{uuid}/publish': {
        get: {
            req: PublishFeedbackData;
            res: {
                /**
                 * User feedback published.
                 */
                204: string;
                /**
                 * Operation not allowed. Only Reviewvers can access it.
                 */
                403: string;
                /**
                 * Resource not found.
                 */
                404: string;
            };
        };
    };
    '/users': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<User>;
            };
        };
        put: {
            req: CreateUserData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/users/groups': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<UserGroupsResponse>;
            };
        };
    };
    '/users/owners': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<OwnerResponse>;
            };
        };
        put: {
            req: SaveOwnersData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/users/properties/{property}': {
        get: {
            req: CheckUserPropertyExistData;
            res: {
                /**
                 * Property does not exist.
                 */
                200: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
                /**
                 * A property with that value already exist.
                 */
                404: 'CONTINUE' | 'SWITCHING_PROTOCOLS' | 'PROCESSING' | 'CHECKPOINT' | 'OK' | 'CREATED' | 'ACCEPTED' | 'NON_AUTHORITATIVE_INFORMATION' | 'NO_CONTENT' | 'RESET_CONTENT' | 'PARTIAL_CONTENT' | 'MULTI_STATUS' | 'ALREADY_REPORTED' | 'IM_USED' | 'MULTIPLE_CHOICES' | 'MOVED_PERMANENTLY' | 'FOUND' | 'MOVED_TEMPORARILY' | 'SEE_OTHER' | 'NOT_MODIFIED' | 'USE_PROXY' | 'TEMPORARY_REDIRECT' | 'PERMANENT_REDIRECT' | 'BAD_REQUEST' | 'UNAUTHORIZED' | 'PAYMENT_REQUIRED' | 'FORBIDDEN' | 'NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'NOT_ACCEPTABLE' | 'PROXY_AUTHENTICATION_REQUIRED' | 'REQUEST_TIMEOUT' | 'CONFLICT' | 'GONE' | 'LENGTH_REQUIRED' | 'PRECONDITION_FAILED' | 'PAYLOAD_TOO_LARGE' | 'REQUEST_ENTITY_TOO_LARGE' | 'URI_TOO_LONG' | 'REQUEST_URI_TOO_LONG' | 'UNSUPPORTED_MEDIA_TYPE' | 'REQUESTED_RANGE_NOT_SATISFIABLE' | 'EXPECTATION_FAILED' | 'I_AM_A_TEAPOT' | 'INSUFFICIENT_SPACE_ON_RESOURCE' | 'METHOD_FAILURE' | 'DESTINATION_LOCKED' | 'UNPROCESSABLE_ENTITY' | 'LOCKED' | 'FAILED_DEPENDENCY' | 'TOO_EARLY' | 'UPGRADE_REQUIRED' | 'PRECONDITION_REQUIRED' | 'TOO_MANY_REQUESTS' | 'REQUEST_HEADER_FIELDS_TOO_LARGE' | 'UNAVAILABLE_FOR_LEGAL_REASONS' | 'INTERNAL_SERVER_ERROR' | 'NOT_IMPLEMENTED' | 'BAD_GATEWAY' | 'SERVICE_UNAVAILABLE' | 'GATEWAY_TIMEOUT' | 'HTTP_VERSION_NOT_SUPPORTED' | 'VARIANT_ALSO_NEGOTIATES' | 'INSUFFICIENT_STORAGE' | 'LOOP_DETECTED' | 'BANDWIDTH_LIMIT_EXCEEDED' | 'NOT_EXTENDED' | 'NETWORK_AUTHENTICATION_REQUIRED';
            };
        };
    };
    '/users/{userIdentifier}': {
        delete: {
            req: DeleteUserData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
        get: {
            req: GetUserData;
            res: {
                /**
                 * OK
                 */
                200: User;
            };
        };
        put: {
            req: UpdateUserData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/users/{userIdentifier}.png': {
        get: {
            req: GetUserIdenticonData;
            res: {
                /**
                 * OK
                 */
                200: unknown;
            };
        };
    };
    '/users/{userIdentifier}/actions/forget-password': {
        post: {
            req: ResetUserPasswordData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
    };
    '/users/{userIdentifier}/groups': {
        get: {
            req: RetrieveUserGroupsData;
            res: {
                /**
                 * OK
                 */
                200: Array<UserGroup>;
            };
        };
    };
    '/usersearches': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<UserSearchDto>;
            };
        };
        put: {
            req: CreateUserCustomSearchData;
            res: {
                /**
                 * User search created.
                 */
                201: number;
            };
        };
    };
    '/usersearches/all': {
        get: {
            req: GetAllUserCustomSearchesData;
            res: {
                /**
                 * OK
                 */
                200: Array<UserSearchDto>;
            };
        };
    };
    '/usersearches/allpaginated': {
        get: {
            req: GetAllUserCustomSearchesPageData;
            res: {
                /**
                 * OK
                 */
                200: PaginatedUserSearchResponse;
            };
        };
    };
    '/usersearches/featured': {
        get: {
            req: GetFeaturedUserCustomSearchesData;
            res: {
                /**
                 * OK
                 */
                200: Array<UserSearchDto>;
            };
        };
    };
    '/usersearches/{searchIdentifier}': {
        delete: {
            req: DeleteUserCustomSerachData;
            res: {
                /**
                 * OK
                 */
                200: string;
            };
        };
        get: {
            req: GetUserCustomSearchData;
            res: {
                /**
                 * OK
                 */
                200: UserSearchDto;
            };
        };
        put: {
            req: UpdateCustomUserSearchData;
            res: {
                /**
                 * User search  updated.
                 */
                204: void;
                /**
                 * Resource not found.
                 */
                404: unknown;
            };
        };
    };
    '/userselections': {
        get: {
            res: {
                /**
                 * OK
                 */
                200: Array<Selection>;
            };
        };
        put: {
            req: CreatePersistentSelectionTypeData;
            res: {
                /**
                 * Selection created.
                 */
                201: string;
                /**
                 * A selection with that id or name already exist.
                 */
                400: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
            };
        };
    };
    '/userselections/{selectionIdentifier}': {
        delete: {
            req: DeleteUserSelectionData;
            res: {
                /**
                 * Selection removed.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * Selection not found.
                 */
                404: string;
            };
        };
        put: {
            req: UpdateUserSelectionData;
            res: {
                /**
                 * Selection updated.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * Selection not found.
                 */
                404: string;
            };
        };
    };
    '/userselections/{selectionIdentifier}/{userIdentifier}': {
        delete: {
            req: DeleteFromUserSelectionData;
            res: {
                /**
                 * Items removed from a set.
                 */
                204: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * Selection or user not found.
                 */
                404: string;
            };
        };
        get: {
            req: GetSelectionRecordsData;
            res: {
                /**
                 * OK
                 */
                200: Array<(string)>;
            };
        };
        put: {
            req: AddToUserSelectionData;
            res: {
                /**
                 * Records added to selection set.
                 */
                201: string;
                /**
                 * Operation not allowed. Only UserAdmins can access it.
                 */
                403: string;
                /**
                 * Selection or user or at least one UUID not found.
                 */
                404: string;
            };
        };
    };
};
